; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\Callback.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_IID_IMetaDataEmit
PUBLIC	_IID_IMetaDataImport
PUBLIC	_IID_IMetaDataAssemblyImport
;	COMDAT _IID_IMetaDataAssemblyImport
CONST	SEGMENT
_IID_IMetaDataAssemblyImport DD 0ee62470bH
	DW	0e94bH
	DW	0424eH
	DB	09bH
	DB	07cH
	DB	02fH
	DB	00H
	DB	0c9H
	DB	024H
	DB	09fH
	DB	093H
CONST	ENDS
;	COMDAT _IID_IMetaDataImport
CONST	SEGMENT
_IID_IMetaDataImport DD 07dac8207H
	DW	0d3aeH
	DW	04c75H
	DB	09bH
	DB	067H
	DB	092H
	DB	080H
	DB	01aH
	DB	049H
	DB	07dH
	DB	044H
CONST	ENDS
;	COMDAT _IID_IMetaDataEmit
CONST	SEGMENT
_IID_IMetaDataEmit DD 0ba3fee4cH
	DW	0ecb9H
	DW	04e41H
	DB	083H
	DB	0b7H
	DB	018H
	DB	03fH
	DB	0a4H
	DB	01cH
	DB	0d8H
	DB	059H
_g_tkCorEncodeToken DD 02000000H
	DD	01000000H
	DD	01b000000H
	DD	072000000H
PUBLIC	?FunctionLeaveNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_RANGE@@@Z ; FunctionLeaveNaked
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\callback.cpp
;	COMDAT ?FunctionLeaveNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_RANGE@@@Z
_TEXT	SEGMENT
_functionID$ = 8					; size = 4
_clientData$ = 12					; size = 4
_func$ = 16						; size = 4
_retvalRange$ = 20					; size = 4
?FunctionLeaveNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_RANGE@@@Z PROC ; FunctionLeaveNaked, COMDAT

; 73   : 	__asm
; 74   : 	{
; 75   : 		#define CallPopSize 0
; 76   : 		#define SavedRegisterOffset CallPopSize
; 77   : 		#define SavedRegister(X) [esp + SavedRegisterOffset + X]
; 78   : 		#define SavedFPRegister(X) [esp + SavedRegisterOffset + 12 + X]
; 79   : 		#define SavedFloatRegisterSize 12
; 80   : 		#define SavedRegisterSize 12 + SavedFloatRegisterSize
; 81   : 		#define FrameSize (SavedRegisterOffset + SavedRegisterSize)
; 82   : 		
; 83   : 		sub esp, FrameSize

	sub	esp, 24					; 00000018H

; 84   : 		mov SavedRegister(8), eax

	mov	DWORD PTR [esp+8], eax

; 85   : 		mov SavedRegister(4), ecx

	mov	DWORD PTR [esp+4], ecx

; 86   : 		mov SavedRegister(0), edx

	mov	DWORD PTR [esp], edx

; 87   : 		
; 88   : 		// Check if there's anything on the FP stack.
; 89   : 		//
; 90   : 		// Again technically you need only save what you use. You might think that
; 91   : 		// FP regs are not commonly used in the kind of code you'd write in these,
; 92   : 		// but there are common cases that might interfere. For example, in the 8.0 MS CRT, 
; 93   : 		// memcpy clears the FP stack.
; 94   : 		//
; 95   : 		// In CLR versions 1.x and 2.0, everything from here to NoSaveFPReg
; 96   : 		// is only strictly necessary for FunctionLeave and FunctionLeave2.
; 97   : 		// Of course that may change in future releases, so use this code for all of your
; 98   : 		// enter/leave function hooks if you want to avoid breaking.
; 99   : 		fstsw   ax

	fstsw	ax

; 100  : 		test    ax, 3800h		// Check the top-of-fp-stack bits

	test	ax, 14336				; 00003800H

; 101  : 		jnz     SaveFPReg

	jne	SHORT $SaveFPReg$67220

; 102  : 		mov     dword ptr SavedFPRegister(0), 0 // otherwise, mark that there is no float value

	mov	DWORD PTR [esp+12], 0

; 103  : 		jmp     NoSaveFPReg

	jmp	SHORT $NoSaveFPReg$67221
$SaveFPReg$67220:

; 104  : 	SaveFPReg:
; 105  : 		fstp    qword ptr SavedFPRegister(4) // Copy the FP value to the buffer as a double

	fstp	QWORD PTR [esp+16]

; 106  : 		mov     dword ptr SavedFPRegister(0), 1	// mark that a float value is present

	mov	DWORD PTR [esp+12], 1
$NoSaveFPReg$67221:

; 107  : 	NoSaveFPReg:
; 108  : 		
; 109  : 		
; 110  : 		call    FunctionLeaveGlobal

	call	?FunctionLeaveGlobal@@YIXXZ		; FunctionLeaveGlobal

; 111  : 		// the call causes CallPopSize bytes to be popped from the stack
; 112  : 		
; 113  : 		// Now see if we have to restore any floating point registers
; 114  : 		// In CLR versions 1.x and 2.0, everything from here to 
; 115  : 		// RestoreFPRegsDone is only strictly necessary for FunctionLeave and FunctionLeave2
; 116  : 		// Of course that may change in future releases, so use this code for all of your
; 117  : 		// enter/leave function hooks if you want to avoid breaking.
; 118  : 		cmp     dword ptr SavedFPRegister(0 - CallPopSize), 0		// Check the flag

	cmp	DWORD PTR [esp+12], 0

; 119  : 		jz      NoRestoreFPRegs		// If zero, no FP regs

	je	SHORT $NoRestoreFPRegs$67222

; 120  : 	//RestoreFPRegs:
; 121  : 		fld     qword ptr SavedFPRegister(4 - CallPopSize)	// Restore FP regs

	fld	QWORD PTR [esp+16]
$NoRestoreFPRegs$67222:

; 122  : 	NoRestoreFPRegs:
; 123  : 	//RestoreFPRegsDone:
; 124  : 		
; 125  : 		mov edx, SavedRegister(0 - CallPopSize)

	mov	edx, DWORD PTR [esp]

; 126  : 		mov ecx, SavedRegister(4 - CallPopSize)

	mov	ecx, DWORD PTR [esp+4]

; 127  : 		mov eax, SavedRegister(8 - CallPopSize)

	mov	eax, DWORD PTR [esp+8]

; 128  : 		add esp, FrameSize - CallPopSize

	add	esp, 24					; 00000018H

; 129  : 		ret    16

	ret	16					; 00000010H
?FunctionLeaveNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_RANGE@@@Z ENDP ; FunctionLeaveNaked
PUBLIC	?FunctionTailcallNaked@@YAXIII@Z		; FunctionTailcallNaked
; Function compile flags: /Ogtpy
;	COMDAT ?FunctionTailcallNaked@@YAXIII@Z
_TEXT	SEGMENT
_functionID$ = 8					; size = 4
_clientData$ = 12					; size = 4
_func$ = 16						; size = 4
?FunctionTailcallNaked@@YAXIII@Z PROC			; FunctionTailcallNaked, COMDAT

; 139  : 	__asm
; 140  : 	{
; 141  : 		#define CallPopSize 0
; 142  : 		#define SavedRegisterOffset CallPopSize
; 143  : 		#define SavedRegister(X) [esp + SavedRegisterOffset + X]
; 144  : 		#define SavedRegisterSize 12
; 145  : 		#define FrameSize (SavedRegisterOffset + SavedRegisterSize)
; 146  : 		
; 147  : 		sub esp, FrameSize

	sub	esp, 12					; 0000000cH

; 148  : 		// eax, ecx and edx are scratch registers in stdcall, so we need to save those
; 149  : 		mov SavedRegister(8), eax

	mov	DWORD PTR [esp+8], eax

; 150  : 		mov SavedRegister(4), ecx

	mov	DWORD PTR [esp+4], ecx

; 151  : 		mov SavedRegister(0), edx

	mov	DWORD PTR [esp], edx

; 152  : 				
; 153  : 		call    FunctionTailcallGlobal

	call	?FunctionTailcallGlobal@@YIXXZ		; FunctionTailcallGlobal

; 154  : 		// the call causes CallPopSize bytes to be popped from the stack
; 155  : 				
; 156  : 		mov edx, SavedRegister(0 - CallPopSize)

	mov	edx, DWORD PTR [esp]

; 157  : 		mov ecx, SavedRegister(4 - CallPopSize)

	mov	ecx, DWORD PTR [esp+4]

; 158  : 		mov eax, SavedRegister(8 - CallPopSize)

	mov	eax, DWORD PTR [esp+8]

; 159  : 		
; 160  : 		add esp, FrameSize - CallPopSize

	add	esp, 12					; 0000000cH

; 161  : 		ret    12

	ret	12					; 0000000cH
?FunctionTailcallNaked@@YAXIII@Z ENDP			; FunctionTailcallNaked
PUBLIC	?FunctionEnterNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_INFO@@@Z ; FunctionEnterNaked
; Function compile flags: /Ogtpy
;	COMDAT ?FunctionEnterNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_INFO@@@Z
_TEXT	SEGMENT
_functionID$ = 8					; size = 4
_clientData$ = 12					; size = 4
_func$ = 16						; size = 4
_argumentInfo$ = 20					; size = 4
?FunctionEnterNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_INFO@@@Z PROC ; FunctionEnterNaked, COMDAT

; 29   : 	__asm
; 30   : 	{
; 31   : 		#define CallPopSize 0
; 32   : 		#define SavedRegisterOffset CallPopSize
; 33   : 		#define SavedRegister(X) [esp + SavedRegisterOffset + X]
; 34   : 		#define SavedRegisterSize 12
; 35   : 		#define FrameSize (SavedRegisterOffset + SavedRegisterSize)
; 36   : 		
; 37   : 		// stack layout:
; 38   : 		// esp +  0   -> saved edx
; 39   : 		//     +  4   -> saved ecx
; 40   : 		//     +  8   -> saved eax
; 41   : 		//     + 12   -> return address
; 42   : 		//     + 16   -> functionID      \
; 43   : 		//     + 20   -> clientData      |- parameters for FunctionEnterNaked
; 44   : 		//     + 24   -> frameInfo       |
; 45   : 		//     + 28   -> argumentInfo    /
; 46   : 		
; 47   : 		sub esp, FrameSize

	sub	esp, 12					; 0000000cH

; 48   : 		// eax, ecx and edx are scratch registers in fastcall, so we need to save those
; 49   : 		mov SavedRegister(8), eax

	mov	DWORD PTR [esp+8], eax

; 50   : 		mov SavedRegister(4), ecx

	mov	DWORD PTR [esp+4], ecx

; 51   : 		mov SavedRegister(0), edx

	mov	DWORD PTR [esp], edx

; 52   : 		
; 53   : 		mov ecx, [esp+FrameSize+8] // get clientData = custom FunctionID

	mov	ecx, DWORD PTR [esp+20]

; 54   : 		// first argument to FunctionEnterGlobal is in ecx (__fastcall)
; 55   : 		
; 56   : 		call    FunctionEnterGlobal

	call	?FunctionEnterGlobal@@YIXH@Z		; FunctionEnterGlobal

; 57   : 		// the call causes CallPopSize bytes to be popped from the stack
; 58   : 		
; 59   : 		mov edx, SavedRegister(0 - CallPopSize)

	mov	edx, DWORD PTR [esp]

; 60   : 		mov ecx, SavedRegister(4 - CallPopSize)

	mov	ecx, DWORD PTR [esp+4]

; 61   : 		mov eax, SavedRegister(8 - CallPopSize)

	mov	eax, DWORD PTR [esp+8]

; 62   : 		
; 63   : 		add esp, FrameSize - CallPopSize

	add	esp, 12					; 0000000cH

; 64   : 		ret    16

	ret	16					; 00000010H
?FunctionEnterNaked@@YAXIIIPAU_COR_PRF_FUNCTION_ARGUMENT_INFO@@@Z ENDP ; FunctionEnterNaked
END
