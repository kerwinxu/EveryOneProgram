; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\CircularBuffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?NextOffset@CCircularBuffer@@AAEHH@Z		; CCircularBuffer::NextOffset
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\circularbuffer.cpp
;	COMDAT ?NextOffset@CCircularBuffer@@AAEHH@Z
_TEXT	SEGMENT
?NextOffset@CCircularBuffer@@AAEHH@Z PROC		; CCircularBuffer::NextOffset, COMDAT
; _this$ = edx
; _offset$ = ecx

; 173  : 	offset += 1;

	inc	ecx

; 174  : 	if (offset == this->dataLength)

	mov	eax, ecx
	sub	eax, DWORD PTR [edx+8]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 175  : 		return 0;
; 176  : 	else
; 177  : 		return offset;
; 178  : }

	ret	0
?NextOffset@CCircularBuffer@@AAEHH@Z ENDP		; CCircularBuffer::NextOffset
PUBLIC	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z	; CCircularBuffer::WriteInternal
; Function compile flags: /Ogtpy
;	COMDAT ?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_offset$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z PROC	; CCircularBuffer::WriteInternal, COMDAT
; _this$ = esi

; 139  : 	// read startOffset and endOffset from shared memory
; 140  : 	int startOffset = this->header->StartOffset;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]

; 141  : 	int endOffset = this->header->EndOffset;

	mov	edx, DWORD PTR [esi]
	push	ebx

; 142  : 	// wait until there's room
; 143  : 	while (NextOffset(endOffset) == startOffset) {

	mov	ebx, DWORD PTR __imp__WaitForSingleObject@8
	push	ebp
	push	edi
	mov	edi, DWORD PTR [edx+12]
	lea	ebp, DWORD PTR [edi+1]
$LL8@WriteInter:
	mov	eax, ebp
	sub	eax, DWORD PTR [esi+8]
	neg	eax
	sbb	eax, eax
	and	eax, ebp
	cmp	eax, ecx
	jne	SHORT $LN7@WriteInter

; 144  : 		if (this->nonFullEvent->Wait() == WAIT_TIMEOUT)

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	push	-1
	push	eax
	call	ebx
	cmp	eax, 258				; 00000102H
	je	SHORT $LN24@WriteInter

; 146  : 		// the reader should have changed the start offset
; 147  : 		startOffset = this->header->StartOffset;

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+8]

; 148  : 	}

	jmp	SHORT $LL8@WriteInter
$LN24@WriteInter:
	pop	edi
	pop	ebp

; 145  : 			return -1;

	or	eax, -1
	pop	ebx

; 169  : }

	ret	12					; 0000000cH
$LN7@WriteInter:

; 149  : 	int writeEndOffset;
; 150  : 	if (startOffset <= endOffset) {

	cmp	ecx, edi
	jg	SHORT $LN5@WriteInter

; 151  : 		// free space wraps over buffer end
; 152  : 		if (startOffset == 0)
; 153  : 			writeEndOffset = this->dataLength - 1; // one byte must always be left free

	mov	eax, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@WriteInter
	dec	eax

; 154  : 		else

	jmp	SHORT $LN2@WriteInter
$LN5@WriteInter:

; 155  : 			writeEndOffset = this->dataLength;
; 156  : 	} else {
; 157  : 		writeEndOffset = startOffset - 1; // one byte must be left free to distinguish between empty and full buffer

	lea	eax, DWORD PTR [ecx-1]
$LN2@WriteInter:

; 158  : 	}
; 159  : 	int writeCount = min(count, writeEndOffset - endOffset);

	mov	ebx, DWORD PTR _count$[esp+8]
	sub	eax, edi
	cmp	ebx, eax
	jl	SHORT $LN12@WriteInter
	mov	ebx, eax
$LN12@WriteInter:

; 160  : 	
; 161  : 	memcpy(this->data + endOffset, data + offset, writeCount);

	mov	edx, DWORD PTR _offset$[esp+8]
	mov	eax, DWORD PTR _data$[esp+8]
	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	add	eax, edx
	push	eax
	add	ecx, edi
	push	ecx
	call	_memcpy

; 162  : 	endOffset += writeCount; // advance endOffset

	add	edi, ebx
	add	esp, 12					; 0000000cH

; 163  : 	if (endOffset == this->dataLength) // wrap around startOffset if required

	cmp	edi, DWORD PTR [esi+8]
	jne	SHORT $LN1@WriteInter

; 164  : 		endOffset = 0;

	xor	edi, edi
$LN1@WriteInter:

; 165  : 
; 166  : 	this->header->EndOffset = endOffset; // write back endOffset to shared memory

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+12], edi

; 167  : 	this->nonEmptyEvent->Set(); // we wrote something, so the buffer is not empty anymore

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
	pop	edi
	pop	ebp

; 168  : 	return writeCount;

	mov	eax, ebx
	pop	ebx

; 169  : }

	ret	12					; 0000000cH
?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ENDP	; CCircularBuffer::WriteInternal
_TEXT	ENDS
PUBLIC	?Write@CCircularBuffer@@QAEHPAEHH@Z		; CCircularBuffer::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CCircularBuffer@@QAEHPAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?Write@CCircularBuffer@@QAEHPAEHH@Z PROC		; CCircularBuffer::Write, COMDAT
; _this$ = ecx
; _count$ = eax

; 99   : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _data$[esp+4]
	push	esi
	xor	ebx, ebx
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 100  : 	if (data == nullptr)

	test	ebp, ebp
	jne	SHORT $LN5@Write
	pop	edi
	pop	esi
	pop	ebp

; 101  : 		return -1;

	or	eax, -1
	pop	ebx

; 113  : }

	ret	4
$LN5@Write:

; 102  : 	if (count < 0)

	test	edi, edi
	jge	SHORT $LN10@Write
	pop	edi
	pop	esi
	pop	ebp

; 103  : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 113  : }

	ret	4
$LN10@Write:

; 104  : 	if (offset < 0)
; 105  : 		return -3;
; 106  : 	
; 107  : 	while (count > 0) {

	jle	SHORT $LN1@Write
	npad	2
$LL2@Write:

; 108  : 		int r = WriteInternal(data, offset, count);

	push	edi
	push	ebx
	push	ebp
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal

; 109  : 		offset += r;
; 110  : 		count -= r;

	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL2@Write
$LN1@Write:

; 111  : 	}
; 112  : 	return count;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 113  : }

	ret	4
?Write@CCircularBuffer@@QAEHPAEHH@Z ENDP		; CCircularBuffer::Write
_TEXT	ENDS
PUBLIC	??0CCircularBuffer@@QAE@PAX@Z			; CCircularBuffer::CCircularBuffer
; Function compile flags: /Ogtpy
;	COMDAT ??0CCircularBuffer@@QAE@PAX@Z
_TEXT	SEGMENT
??0CCircularBuffer@@QAE@PAX@Z PROC			; CCircularBuffer::CCircularBuffer, COMDAT
; _this$ = esi
; _start$ = eax

; 24   : {

	push	ebx

; 25   : 	this->header = (CircularBufferHeader*)start;
; 26   : 	if (this->header->Magic != '~CB1') {
; 27   : 		DebugWriteLine(L"Corrupted buffer header");
; 28   : 	}
; 29   : 	this->data = (byte*)(this->header + 1);

	lea	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx

; 30   : 	this->dataLength = this->header->TotalLength - sizeof(CircularBufferHeader);

	mov	edx, DWORD PTR [eax+4]
	push	ebp
	push	edi
	sub	edx, 24					; 00000018H
	mov	DWORD PTR [esi+8], edx

; 31   : 	this->nonFullEvent = OpenEventWaitHandle(GetEventName(this->header->NonFullEventName));

	mov	edi, DWORD PTR [eax+20]
	push	128					; 00000080H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, DWORD PTR __imp__sprintf_s
	push	edi
	push	OFFSET ??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	ebx, eax
	push	128					; 00000080H
	push	ebx
	call	ebp
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	je	SHORT $LN11@CCircularB
	push	ebx
	push	0
	push	1048578					; 00100002H
	mov	DWORD PTR [edi], ebx
	call	DWORD PTR __imp__OpenEventA@12
	mov	DWORD PTR [edi+4], eax
	mov	eax, edi
	jmp	SHORT $LN12@CCircularB
$LN11@CCircularB:
	xor	eax, eax
$LN12@CCircularB:
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@CCircularB
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
$LN8@CCircularB:
	mov	DWORD PTR [esi+16], eax

; 32   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+16]
	push	128					; 00000080H
	call	??_U@YAPAXI@Z				; operator new[]
	push	edi
	push	OFFSET ??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	ebx, eax
	push	128					; 00000080H
	push	ebx
	call	ebp
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	je	SHORT $LN23@CCircularB
	push	ebx
	push	0
	push	1048578					; 00100002H
	mov	DWORD PTR [edi], ebx
	call	DWORD PTR __imp__OpenEventA@12
	mov	DWORD PTR [edi+4], eax
	jmp	SHORT $LN24@CCircularB
$LN23@CCircularB:
	xor	edi, edi
$LN24@CCircularB:
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN20@CCircularB
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	xor	eax, eax
	pop	ebp
	mov	DWORD PTR [esi+12], eax

; 33   : 
; 34   : 	if (this->nonFullEvent != nullptr)
; 35   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 36   : 	if (this->nonEmptyEvent != nullptr)
; 37   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 38   : 
; 39   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 40   : }

	mov	eax, esi
	pop	ebx
	ret	0

; 32   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

$LN20@CCircularB:
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	ebp

; 33   : 
; 34   : 	if (this->nonFullEvent != nullptr)
; 35   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 36   : 	if (this->nonEmptyEvent != nullptr)
; 37   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 38   : 
; 39   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 40   : }

	mov	eax, esi
	pop	ebx
	ret	0
??0CCircularBuffer@@QAE@PAX@Z ENDP			; CCircularBuffer::CCircularBuffer
PUBLIC	?WriteInt@CCircularBuffer@@QAEHH@Z		; CCircularBuffer::WriteInt
; Function compile flags: /Ogtpy
;	COMDAT ?WriteInt@CCircularBuffer@@QAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?WriteInt@CCircularBuffer@@QAEHH@Z PROC			; CCircularBuffer::WriteInt, COMDAT
; _this$ = eax

; 126  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, eax

; 127  : 	return Write((byte*)&data, 0, 4);

	mov	edi, 4
	xor	ebx, ebx
	npad	4
$LL4@WriteInt:
	push	edi
	push	ebx
	lea	eax, DWORD PTR _data$[esp+16]
	push	eax
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal
	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL4@WriteInt
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 128  : }

	ret	4
?WriteInt@CCircularBuffer@@QAEHH@Z ENDP			; CCircularBuffer::WriteInt
PUBLIC	?WriteString@CCircularBuffer@@QAEHPA_W@Z	; CCircularBuffer::WriteString
; Function compile flags: /Ogtpy
;	COMDAT ?WriteString@CCircularBuffer@@QAEHPA_W@Z
_TEXT	SEGMENT
$T156539 = -4						; size = 4
_string$ = 8						; size = 4
?WriteString@CCircularBuffer@@QAEHPA_W@Z PROC		; CCircularBuffer::WriteString, COMDAT
; _this$ = eax

; 131  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 132  : 	int len = (int)(wcslen(string) * sizeof(WCHAR));

	mov	eax, DWORD PTR _string$[esp+12]
	push	edi
	lea	edx, DWORD PTR [eax+2]
	npad	2
$LL17@WriteStrin:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL17@WriteStrin
	sub	eax, edx
	sar	eax, 1
	lea	ebp, DWORD PTR [eax+eax]

; 133  : 	WriteInt(len);

	mov	DWORD PTR $T156539[esp+20], ebp
	mov	edi, 4
	xor	ebx, ebx
	npad	3
$LL6@WriteStrin:
	push	edi
	push	ebx
	lea	eax, DWORD PTR $T156539[esp+28]
	push	eax
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal
	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL6@WriteStrin

; 134  : 	return Write((byte *)string, 0, len);

	mov	ecx, DWORD PTR _string$[esp+16]
	push	ecx
	mov	eax, ebp
	mov	ecx, esi
	call	?Write@CCircularBuffer@@QAEHPAEHH@Z	; CCircularBuffer::Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 135  : }

	pop	ecx
	ret	4
?WriteString@CCircularBuffer@@QAEHPA_W@Z ENDP		; CCircularBuffer::WriteString
END
