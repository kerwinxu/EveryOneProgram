; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\Profiler.Rewriting.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?JITCompilationStarted@CProfiler@@UAGJIH@Z	; CProfiler::JITCompilationStarted
PUBLIC	?ModuleLoadFinished@CProfiler@@UAGJIJ@Z		; CProfiler::ModuleLoadFinished
PUBLIC	?IsTiny@tagCOR_ILMETHOD_TINY@@QBE_NXZ		; tagCOR_ILMETHOD_TINY::IsTiny
PUBLIC	?GetCodeSize@tagCOR_ILMETHOD_TINY@@QBEIXZ	; tagCOR_ILMETHOD_TINY::GetCodeSize
PUBLIC	?IsFat@tagCOR_ILMETHOD_FAT@@QBE_NXZ		; tagCOR_ILMETHOD_FAT::IsFat
PUBLIC	?GetCodeSize@tagCOR_ILMETHOD_FAT@@QBEIXZ	; tagCOR_ILMETHOD_FAT::GetCodeSize
PUBLIC	?GetSize@tagCOR_ILMETHOD_FAT@@QBEIXZ		; tagCOR_ILMETHOD_FAT::GetSize
PUBLIC	?GetCode@tagCOR_ILMETHOD_FAT@@QBEPAEXZ		; tagCOR_ILMETHOD_FAT::GetCode
PUBLIC	?GetSect@tagCOR_ILMETHOD_FAT@@QBEPBUCOR_ILMETHOD_SECT@@XZ ; tagCOR_ILMETHOD_FAT::GetSect
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator*
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator*
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->
PUBLIC	?Kind@COR_ILMETHOD_SECT@@QBE?AW4CorILMethodSect@@XZ ; COR_ILMETHOD_SECT::Kind
PUBLIC	?Data@tagCOR_ILMETHOD_SECT_SMALL@@QBEPBEXZ	; tagCOR_ILMETHOD_SECT_SMALL::Data
PUBLIC	?Data@tagCOR_ILMETHOD_SECT_FAT@@QBEPBEXZ	; tagCOR_ILMETHOD_SECT_FAT::Data
PUBLIC	?More@COR_ILMETHOD_SECT@@QBE_NXZ		; COR_ILMETHOD_SECT::More
PUBLIC	?Align@COR_ILMETHOD_SECT@@QBEPBU1@XZ		; COR_ILMETHOD_SECT::Align
PUBLIC	?AsFat@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_FAT@@XZ ; COR_ILMETHOD_SECT::AsFat
PUBLIC	?Next@COR_ILMETHOD_SECT@@QBEPBU1@XZ		; COR_ILMETHOD_SECT::Next
PUBLIC	?GetDataSize@tagCOR_ILMETHOD_SECT_FAT@@QBEIXZ	; tagCOR_ILMETHOD_SECT_FAT::GetDataSize
PUBLIC	?AsSmall@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_SMALL@@XZ ; COR_ILMETHOD_SECT::AsSmall
PUBLIC	?IsFat@COR_ILMETHOD_SECT@@QBE_NXZ		; COR_ILMETHOD_SECT::IsFat
PUBLIC	?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ		; COR_ILMETHOD_SECT_EH::EHCount
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,HandlerInfo> >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::max_size
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node::_Node
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Buynode
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Insert
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator--
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::insert
PUBLIC	?_Kfn@?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::_Kfn
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIVHandlerInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Myval
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Key
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lbound
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::lower_bound
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::find
PUBLIC	??0HandlerInfo@@QAE@III@Z			; HandlerInfo::HandlerInfo
PUBLIC	??0?$pair@IVHandlerInfo@@@std@@QAE@ABIABVHandlerInfo@@@Z ; std::pair<unsigned int,HandlerInfo>::pair<unsigned int,HandlerInfo>
PUBLIC	??$?0IVHandlerInfo@@@?$pair@$$CBIVHandlerInfo@@@std@@QAE@ABU?$pair@IVHandlerInfo@@@1@@Z ; std::pair<unsigned int const ,HandlerInfo>::pair<unsigned int const ,HandlerInfo><unsigned int,HandlerInfo>
PUBLIC	?wcsstr@@YAPA_WPA_WPB_W@Z			; wcsstr
PUBLIC	??_C@_1DK@MJJIEBEI@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?4?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?4?$AAF?$AAo?$AAr?$AAm?$AAs?$AA?4?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EEJFNHLH@?$AAg?$AAe?$AAt?$AA_?$AAN?$AAa?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@ELONGLLO@?$AAg?$AAe?$AAt?$AA_?$AAT?$AAe?$AAx?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CBDINCKK@?$AAH?$AAo?$AAo?$AAk?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@IGFKGMEH@?$AAD?$AAe?$AAa?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@HDGCFJKN@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@HNBEDEIN@?$AAL?$AAo?$AAg?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
EXTRN	__imp__wcsstr:PROC
;	COMDAT ??_C@_1BC@HNBEDEIN@?$AAL?$AAo?$AAg?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@HNBEDEIN@?$AAL?$AAo?$AAg?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ DB 'L'
	DB	00H, 'o', 00H, 'g', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HDGCFJKN@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HDGCFJKN@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@ DB 'A'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'r', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@IGFKGMEH@?$AAD?$AAe?$AAa?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@IGFKGMEH@?$AAD?$AAe?$AAa?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@ DB 'D'
	DB	00H, 'e', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CBDINCKK@?$AAH?$AAo?$AAo?$AAk?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CBDINCKK@?$AAH?$AAo?$AAo?$AAk?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'H'
	DB	00H, 'o', 00H, 'o', 00H, 'k', 00H, '3', 00H, '2', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ELONGLLO@?$AAg?$AAe?$AAt?$AA_?$AAT?$AAe?$AAx?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@ELONGLLO@?$AAg?$AAe?$AAt?$AA_?$AAT?$AAe?$AAx?$AAt?$AA?$AA@ DB 'g'
	DB	00H, 'e', 00H, 't', 00H, '_', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EEJFNHLH@?$AAg?$AAe?$AAt?$AA_?$AAN?$AAa?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EEJFNHLH@?$AAg?$AAe?$AAt?$AA_?$AAN?$AAa?$AAm?$AAe?$AA?$AA@ DB 'g'
	DB	00H, 'e', 00H, 't', 00H, '_', 00H, 'N', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MJJIEBEI@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?4?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?4?$AAF?$AAo?$AAr?$AAm?$AAs?$AA?4?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@MJJIEBEI@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?4?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?4?$AAF?$AAo?$AAr?$AAm?$AAs?$AA?4?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@ DB 'S'
	DB	00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, '.', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's'
	DB	00H, '.', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 's', 00H
	DB	'.', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
_g_tkCorEncodeToken DD 02000000H
	DD	01000000H
	DD	01b000000H
	DD	072000000H
_rgSig	DB	00H
	DB	00H
	DB	01H
	ORG $+1
_loggerSig DB	00H
	DB	04H
	DB	01H
	DB	08H
	DB	08H
	DB	0eH
	DB	0eH
	ORG $+1
_getNameSig DB	020H
	DB	00H
	DB	0eH
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$?0IVHandlerInfo@@@?$pair@$$CBIVHandlerInfo@@@std@@QAE@ABU?$pair@IVHandlerInfo@@@1@@Z
_TEXT	SEGMENT
??$?0IVHandlerInfo@@@?$pair@$$CBIVHandlerInfo@@@std@@QAE@ABU?$pair@IVHandlerInfo@@@1@@Z PROC ; std::pair<unsigned int const ,HandlerInfo>::pair<unsigned int const ,HandlerInfo><unsigned int,HandlerInfo>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 49   : 		{	// construct from compatible pair

	mov	edx, DWORD PTR [ecx]
	add	ecx, 4
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], ecx

; 50   : 		}

	ret	0
??$?0IVHandlerInfo@@@?$pair@$$CBIVHandlerInfo@@@std@@QAE@ABU?$pair@IVHandlerInfo@@@1@@Z ENDP ; std::pair<unsigned int const ,HandlerInfo>::pair<unsigned int const ,HandlerInfo><unsigned int,HandlerInfo>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Val$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], ecx
	xor	cl, cl
	mov	BYTE PTR [eax+28], cl
	mov	BYTE PTR [eax+29], cl

; 39   : 			}

	ret	12					; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,HandlerInfo> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,HandlerInfo> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::max_size, COMDAT

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIVHandlerInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIVHandlerInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIVHandlerInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 42   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 43   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIVHandlerInfo@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIVHandlerInfo@@@2@@Z PROC ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 65   : 		return (_Val.first);
; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIVHandlerInfo@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@IVHandlerInfo@@@std@@QAE@ABIABVHandlerInfo@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
??0?$pair@IVHandlerInfo@@@std@@QAE@ABIABVHandlerInfo@@@Z PROC ; std::pair<unsigned int,HandlerInfo>::pair<unsigned int,HandlerInfo>, COMDAT
; _this$ = eax
; __Val2$ = ecx

; 42   : 		{	// construct from specified values

	mov	edx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], ecx

; 43   : 		}

	ret	4
??0?$pair@IVHandlerInfo@@@std@@QAE@ABIABVHandlerInfo@@@Z ENDP ; std::pair<unsigned int,HandlerInfo>::pair<unsigned int,HandlerInfo>
_TEXT	ENDS
PUBLIC	?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z ; CProfiler::CreateMethod
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\profiler.rewriting.cpp
;	COMDAT ?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_moduleRef$ = 12					; size = 4
?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z PROC ; CProfiler::CreateMethod, COMDAT
; _emitter$ = esi
; _methodDefinition$ = edi

; 313  : 	HRESULT hr = emitter->DefineMethod(mdTokenNil, name, mdPublic | mdStatic | mdPinvokeImpl, sig, sizeof(sig), 0, miIL | miManaged, methodDefinition);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+40]
	push	ebx
	mov	ebx, DWORD PTR _name$[esp]
	push	edi
	push	0
	push	0
	push	4
	push	OFFSET _rgSig
	push	8214					; 00002016H
	push	ebx
	push	0
	push	esi
	call	ecx

; 314  : 	
; 315  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jge	SHORT $LN2@CreateMeth

; 316  : 		return false;

	xor	al, al
	pop	ebx

; 321  : 		return false;
; 322  : 	
; 323  : 	return true;
; 324  : }

	ret	8
$LN2@CreateMeth:

; 317  : 	
; 318  : 	hr = emitter->DefinePinvokeMap(*methodDefinition, pmNoMangle | pmCallConvStdcall, name, moduleRef);

	mov	eax, DWORD PTR _moduleRef$[esp]
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+136]
	push	eax
	push	ebx
	push	769					; 00000301H
	push	ecx
	push	esi
	call	edx

; 319  : 	
; 320  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	setge	al
	pop	ebx

; 321  : 		return false;
; 322  : 	
; 323  : 	return true;
; 324  : }

	ret	8
?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z ENDP ; CProfiler::CreateMethod
_TEXT	ENDS
PUBLIC	?ConvertToFat@CProfiler@@AAEXPAEPAH@Z		; CProfiler::ConvertToFat
; Function compile flags: /Ogtpy
;	COMDAT ?ConvertToFat@CProfiler@@AAEXPAEPAH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?ConvertToFat@CProfiler@@AAEXPAEPAH@Z PROC		; CProfiler::ConvertToFat, COMDAT
; _target$ = eax

; 267  : 	COR_ILMETHOD_FAT *targetTable =  (COR_ILMETHOD_FAT *)target;
; 268  :     memset(targetTable, 0, FAT_HEADER_SIZE);

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 269  :     targetTable->Flags = CorILMethod_FatFormat;
; 270  :     targetTable->Size = FAT_HEADER_SIZE / sizeof(DWORD);

	mov	ecx, DWORD PTR [eax]
	and	ecx, -53245				; ffff3003H
	or	ecx, 12291				; 00003003H
	mov	DWORD PTR [eax], ecx

; 271  :     targetTable->MaxStack = DEFAULT_MAX_STACK;

	mov	edx, 8
	mov	WORD PTR [eax+2], dx

; 272  :     *size = FAT_HEADER_SIZE;

	mov	eax, DWORD PTR _size$[esp-4]
	mov	DWORD PTR [eax], 12			; 0000000cH

; 273  : }

	ret	4
?ConvertToFat@CProfiler@@AAEXPAEPAH@Z ENDP		; CProfiler::ConvertToFat
_TEXT	ENDS
PUBLIC	?SetInjectionCode@CProfiler@@AAEHPAUIMetaDataImport@@PAEPAHIIIHH@Z ; CProfiler::SetInjectionCode
; Function compile flags: /Ogtpy
;	COMDAT ?SetInjectionCode@CProfiler@@AAEHPAUIMetaDataImport@@PAEPAHIIIHH@Z
_TEXT	SEGMENT
_getTextToken$ = -8					; size = 4
_start$ = -4						; size = 4
_controlType$ = 8					; size = 4
_metaData$ = 8						; size = 4
_activateCall$ = 12					; size = 4
_loggerCall$ = 16					; size = 4
_getNameToken$ = 20					; size = 4
_nameId$ = 20						; size = 4
?SetInjectionCode@CProfiler@@AAEHPAUIMetaDataImport@@PAEPAHIIIHH@Z PROC ; CProfiler::SetInjectionCode, COMDAT
; _buffer$ = esi
; _size$ = edi
; _deactivateCall$ = edx
; _type$ = ecx

; 186  : 									int type, int nameId) {

	sub	esp, 8

; 187  : 	HRESULT hr = S_OK;
; 188  : 	
; 189  : 	int start = *size;

	mov	eax, DWORD PTR [edi]

; 190  : 
; 191  : 	buffer[(*size)++] = 0x28; //call

	mov	BYTE PTR [eax+esi], 40			; 00000028H

; 192  : 	*(mdMethodDef*)(&buffer[*size]) = deactivateCall;

	mov	DWORD PTR [eax+esi+1], edx

; 193  : 	*size += sizeof(deactivateCall);
; 194  : 	
; 195  : 	buffer[(*size)++] = 0x20; //ldc.i4

	mov	dl, 32					; 00000020H
	mov	BYTE PTR [eax+esi+5], dl

; 196  : 	*(int*)(&buffer[*size]) = type;

	mov	DWORD PTR [eax+esi+6], ecx

; 197  : 	*size += sizeof(type);
; 198  : 	buffer[(*size)++] = 0x20; //ldc.i4

	mov	BYTE PTR [eax+esi+10], dl

; 199  : 	*(int*)(&buffer[*size]) = nameId;

	mov	edx, DWORD PTR _nameId$[esp+4]
	mov	DWORD PTR _start$[esp+8], eax
	mov	DWORD PTR [eax+esi+11], edx

; 200  : 	*size += sizeof(nameId);

	add	eax, 15					; 0000000fH

; 201  : 	
; 202  : 	mdTypeDef controlType = 0;
; 203  : 	mdMethodDef getNameToken = 0;
; 204  : 	mdMethodDef getTextToken = 0;
; 205  : 	
; 206  : 	switch (type) {

	sub	ecx, 1
	push	ebx
	mov	ebx, DWORD PTR _metaData$[esp+8]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR _controlType$[esp+8], 0
	mov	DWORD PTR _getNameToken$[esp+8], 0
	mov	DWORD PTR _getTextToken$[esp+12], 0
	je	$LN9@SetInjecti
	sub	ecx, 1
	je	SHORT $LN8@SetInjecti
	sub	ecx, 1
	jne	$LN10@SetInjecti

; 249  : 		case 3: // WPF
; 250  : 			buffer[(*size)++] = 0x14; //ldnull
; 251  : 			buffer[(*size)++] = 0x14; //ldnull
; 252  : 			break;

	jmp	$LN9@SetInjecti
$LN8@SetInjecti:

; 210  : 			break;
; 211  : 		case 2: // Windows Forms
; 212  : 			hr = metaData->FindTypeDefByName(L"System.Windows.Forms.Control", nullptr, &controlType);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+36]
	lea	ecx, DWORD PTR _controlType$[esp+8]
	push	ecx
	push	0
	push	OFFSET ??_C@_1DK@MJJIEBEI@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?4?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?4?$AAF?$AAo?$AAr?$AAm?$AAs?$AA?4?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?$AA@
	push	ebx
	call	edx

; 213  : 			
; 214  : 			if (!SUCCEEDED(hr) || controlType == 0) {

	test	eax, eax
	jl	SHORT $LN6@SetInjecti
	mov	eax, DWORD PTR _controlType$[esp+8]
	test	eax, eax
	je	SHORT $LN6@SetInjecti

; 217  : 				buffer[(*size)++] = 0x14; //ldnull
; 218  : 				break;
; 219  : 			}
; 220  : 			
; 221  : 			hr = metaData->FindMethod(controlType, L"get_Name", getNameSig, sizeof(getNameSig), &getNameToken);

	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR _getNameToken$[esp+8]
	push	edx
	push	3
	push	OFFSET _getNameSig
	push	OFFSET ??_C@_1BC@EEJFNHLH@?$AAg?$AAe?$AAt?$AA_?$AAN?$AAa?$AAm?$AAe?$AA?$AA@
	push	eax
	mov	eax, DWORD PTR [ecx+108]
	push	ebx
	call	eax

; 222  : 			
; 223  : 			if (!SUCCEEDED(hr) || getNameToken == 0) {

	test	eax, eax
	jl	SHORT $LN6@SetInjecti
	cmp	DWORD PTR _getNameToken$[esp+8], 0
	je	SHORT $LN6@SetInjecti

; 224  : 				DebugWriteLine(L"FindMethod failed");
; 225  : 				buffer[(*size)++] = 0x14; //ldnull
; 226  : 				buffer[(*size)++] = 0x14; //ldnull
; 227  : 				break;
; 228  : 			}
; 229  : 			
; 230  : 			hr = metaData->FindMethod(controlType, L"get_Text", getNameSig, sizeof(getNameSig), &getTextToken);

	mov	eax, DWORD PTR _controlType$[esp+8]
	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+108]
	lea	edx, DWORD PTR _getTextToken$[esp+12]
	push	edx
	push	3
	push	OFFSET _getNameSig
	push	OFFSET ??_C@_1BC@ELONGLLO@?$AAg?$AAe?$AAt?$AA_?$AAT?$AAe?$AAx?$AAt?$AA?$AA@
	push	eax
	push	ebx
	call	ecx

; 231  : 			
; 232  : 			if (!SUCCEEDED(hr) || getTextToken == 0) {

	test	eax, eax
	jl	SHORT $LN6@SetInjecti
	mov	ecx, DWORD PTR _getTextToken$[esp+12]
	test	ecx, ecx
	je	SHORT $LN6@SetInjecti

; 233  : 				DebugWriteLine(L"FindMethod failed");
; 234  : 				buffer[(*size)++] = 0x14; //ldnull
; 235  : 				buffer[(*size)++] = 0x14; //ldnull
; 236  : 				break;
; 237  : 			}
; 238  : 			
; 239  : 			buffer[(*size)++] = 0x02; //ldarg.0

	mov	eax, DWORD PTR [edi]

; 240  : 			buffer[(*size)++] = 0x28; //call
; 241  : 			*(mdMethodDef*)(&buffer[*size]) = getNameToken;

	mov	edx, DWORD PTR _getNameToken$[esp+8]
	mov	BYTE PTR [eax+esi], 2
	mov	BYTE PTR [eax+esi+1], 40		; 00000028H
	mov	DWORD PTR [eax+esi+2], edx

; 242  : 			*size += sizeof(getNameToken);
; 243  : 
; 244  : 			buffer[(*size)++] = 0x02; //ldarg.0

	mov	BYTE PTR [eax+esi+6], 2

; 245  : 			buffer[(*size)++] = 0x6F; //callvirt

	mov	BYTE PTR [eax+esi+7], 111		; 0000006fH

; 246  : 			*(mdMethodDef*)(&buffer[*size]) = getTextToken;

	mov	DWORD PTR [eax+esi+8], ecx

; 247  : 			*size += sizeof(getTextToken);

	add	eax, 12					; 0000000cH

; 248  : 			break;

	jmp	SHORT $LN14@SetInjecti
$LN6@SetInjecti:

; 215  : 				DebugWriteLine(L"FindTypeDefByName failed");
; 216  : 				buffer[(*size)++] = 0x14; //ldnull

	mov	eax, DWORD PTR [edi]
$LN9@SetInjecti:

; 207  : 		case 1: // Console
; 208  : 			buffer[(*size)++] = 0x14; //ldnull

	mov	BYTE PTR [eax+esi], 20			; 00000014H

; 209  : 			buffer[(*size)++] = 0x14; //ldnull

	mov	BYTE PTR [eax+esi+1], 20		; 00000014H
	add	eax, 2
$LN14@SetInjecti:
	mov	DWORD PTR [edi], eax
$LN10@SetInjecti:

; 253  : 	}
; 254  : 	
; 255  : 	buffer[(*size)++] = 0x28; //call

	mov	eax, DWORD PTR [edi]

; 256  : 	*(mdMethodDef*)(&buffer[*size]) = loggerCall;

	mov	ecx, DWORD PTR _loggerCall$[esp+8]

; 257  : 	*size += sizeof(loggerCall);
; 258  : 
; 259  : 	buffer[(*size)++] = 0x28; //call
; 260  : 	*(mdMethodDef*)(&buffer[*size]) = activateCall;

	mov	edx, DWORD PTR _activateCall$[esp+8]
	mov	BYTE PTR [eax+esi], 40			; 00000028H
	mov	DWORD PTR [eax+esi+1], ecx
	mov	BYTE PTR [eax+esi+5], 40		; 00000028H
	mov	DWORD PTR [eax+esi+6], edx

; 261  : 	*size += sizeof(activateCall);

	add	eax, 10					; 0000000aH
	mov	DWORD PTR [edi], eax

; 262  : 	
; 263  : 	return *size - start;

	sub	eax, DWORD PTR _start$[esp+12]
	pop	ebx

; 264  : }

	add	esp, 8
	ret	16					; 00000010H
?SetInjectionCode@CProfiler@@AAEHPAUIMetaDataImport@@PAEPAHIIIHH@Z ENDP ; CProfiler::SetInjectionCode
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\global.h
_TEXT	ENDS
;	COMDAT ??0HandlerInfo@@QAE@III@Z
_TEXT	SEGMENT
_deactivator$ = 8					; size = 4
_logger$ = 12						; size = 4
??0HandlerInfo@@QAE@III@Z PROC				; HandlerInfo::HandlerInfo, COMDAT
; _this$ = eax
; _activator$ = ecx

; 95   : 		{
; 96   : 			this->activator = activator;
; 97   : 			this->deactivator = deactivator;

	mov	edx, DWORD PTR _deactivator$[esp-4]
	mov	DWORD PTR [eax+4], ecx

; 98   : 			this->logger = logger;

	mov	ecx, DWORD PTR _logger$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+8], ecx

; 99   : 		}

	ret	8
??0HandlerInfo@@QAE@III@Z ENDP				; HandlerInfo::HandlerInfo
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v6.0a\include\corhlpr.h
_TEXT	ENDS
;	COMDAT ?GetCodeSize@tagCOR_ILMETHOD_FAT@@QBEIXZ
_TEXT	SEGMENT
?GetCodeSize@tagCOR_ILMETHOD_FAT@@QBEIXZ PROC		; tagCOR_ILMETHOD_FAT::GetCodeSize, COMDAT
; _this$ = eax

; 925  :         return VAL32(CodeSize); 

	mov	eax, DWORD PTR [eax+4]

; 926  :     }

	ret	0
?GetCodeSize@tagCOR_ILMETHOD_FAT@@QBEIXZ ENDP		; tagCOR_ILMETHOD_FAT::GetCodeSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsFat@tagCOR_ILMETHOD_FAT@@QBE_NXZ
_TEXT	SEGMENT
?IsFat@tagCOR_ILMETHOD_FAT@@QBE_NXZ PROC		; tagCOR_ILMETHOD_FAT::IsFat, COMDAT
; _this$ = eax

; 910  :         /* return((IMAGE_COR_ILMETHOD_FAT::GetFlags() & CorILMethod_FormatMask) == CorILMethod_FatFormat); */
; 911  :         return (*(BYTE*)this & CorILMethod_FormatMask) == CorILMethod_FatFormat;

	mov	cl, BYTE PTR [eax]
	and	cl, 7
	xor	eax, eax
	cmp	cl, 3
	sete	al

; 912  :     }

	ret	0
?IsFat@tagCOR_ILMETHOD_FAT@@QBE_NXZ ENDP		; tagCOR_ILMETHOD_FAT::IsFat
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSize@tagCOR_ILMETHOD_FAT@@QBEIXZ
_TEXT	SEGMENT
?GetSize@tagCOR_ILMETHOD_FAT@@QBEIXZ PROC		; tagCOR_ILMETHOD_FAT::GetSize, COMDAT
; _this$ = eax

; 887  :         /* return Size; */
; 888  :         BYTE* p = (BYTE*)this;
; 889  :         return *(p+1) >> 4;

	movzx	eax, BYTE PTR [eax+1]
	shr	eax, 4

; 890  :     }

	ret	0
?GetSize@tagCOR_ILMETHOD_FAT@@QBEIXZ ENDP		; tagCOR_ILMETHOD_FAT::GetSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCodeSize@tagCOR_ILMETHOD_TINY@@QBEIXZ
_TEXT	SEGMENT
?GetCodeSize@tagCOR_ILMETHOD_TINY@@QBEIXZ PROC		; tagCOR_ILMETHOD_TINY::GetCodeSize, COMDAT
; _this$ = eax

; 855  :         return(((unsigned) Flags_CodeSize) >> (CorILMethod_FormatShift-1)); 

	movzx	eax, BYTE PTR [eax]
	shr	eax, 2

; 856  :     }

	ret	0
?GetCodeSize@tagCOR_ILMETHOD_TINY@@QBEIXZ ENDP		; tagCOR_ILMETHOD_TINY::GetCodeSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsTiny@tagCOR_ILMETHOD_TINY@@QBE_NXZ
_TEXT	SEGMENT
?IsTiny@tagCOR_ILMETHOD_TINY@@QBE_NXZ PROC		; tagCOR_ILMETHOD_TINY::IsTiny, COMDAT
; _this$ = eax

; 850  :         return((Flags_CodeSize & (CorILMethod_FormatMask >> 1)) == CorILMethod_TinyFormat); 

	mov	cl, BYTE PTR [eax]
	and	cl, 3
	xor	eax, eax
	cmp	cl, 2
	sete	al

; 851  :     }

	ret	0
?IsTiny@tagCOR_ILMETHOD_TINY@@QBE_NXZ ENDP		; tagCOR_ILMETHOD_TINY::IsTiny
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AsSmall@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_SMALL@@XZ
_TEXT	SEGMENT
?AsSmall@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_SMALL@@XZ PROC ; COR_ILMETHOD_SECT::AsSmall, COMDAT
; _this$ = eax

; 762  :         return((COR_ILMETHOD_SECT_SMALL*) this); 
; 763  :     }

	ret	0
?AsSmall@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_SMALL@@XZ ENDP ; COR_ILMETHOD_SECT::AsSmall
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?AsFat@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_FAT@@XZ
_TEXT	SEGMENT
?AsFat@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_FAT@@XZ PROC ; COR_ILMETHOD_SECT::AsFat, COMDAT
; _this$ = eax

; 757  :         return((COR_ILMETHOD_SECT_FAT*) this); 
; 758  :     }

	ret	0
?AsFat@COR_ILMETHOD_SECT@@IBEPBUtagCOR_ILMETHOD_SECT_FAT@@XZ ENDP ; COR_ILMETHOD_SECT::AsFat
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Align@COR_ILMETHOD_SECT@@QBEPBU1@XZ
_TEXT	SEGMENT
?Align@COR_ILMETHOD_SECT@@QBEPBU1@XZ PROC		; COR_ILMETHOD_SECT::Align, COMDAT
; _this$ = eax

; 751  :         return((COR_ILMETHOD_SECT*) ((((UINT_PTR) this) + 3) & ~3));  

	add	eax, 3
	and	eax, -4					; fffffffcH

; 752  :     }

	ret	0
?Align@COR_ILMETHOD_SECT@@QBEPBU1@XZ ENDP		; COR_ILMETHOD_SECT::Align
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsFat@COR_ILMETHOD_SECT@@QBE_NXZ
_TEXT	SEGMENT
?IsFat@COR_ILMETHOD_SECT@@QBE_NXZ PROC			; COR_ILMETHOD_SECT::IsFat, COMDAT
; _this$ = eax

; 746  :         return((AsSmall()->Kind & CorILMethod_Sect_FatFormat) != 0); 

	movzx	eax, BYTE PTR [eax]
	shr	eax, 6
	and	eax, 1

; 747  :     }

	ret	0
?IsFat@COR_ILMETHOD_SECT@@QBE_NXZ ENDP			; COR_ILMETHOD_SECT::IsFat
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Kind@COR_ILMETHOD_SECT@@QBE?AW4CorILMethodSect@@XZ
_TEXT	SEGMENT
?Kind@COR_ILMETHOD_SECT@@QBE?AW4CorILMethodSect@@XZ PROC ; COR_ILMETHOD_SECT::Kind, COMDAT
; _this$ = eax

; 689  :         return((CorILMethodSect) (AsSmall()->Kind & CorILMethod_Sect_KindMask)); 

	movzx	eax, BYTE PTR [eax]
	and	eax, 63					; 0000003fH

; 690  :     }

	ret	0
?Kind@COR_ILMETHOD_SECT@@QBE?AW4CorILMethodSect@@XZ ENDP ; COR_ILMETHOD_SECT::Kind
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?More@COR_ILMETHOD_SECT@@QBE_NXZ
_TEXT	SEGMENT
?More@COR_ILMETHOD_SECT@@QBE_NXZ PROC			; COR_ILMETHOD_SECT::More, COMDAT
; _this$ = eax

; 684  :         return((AsSmall()->Kind & CorILMethod_Sect_MoreSects) != 0); 

	movzx	eax, BYTE PTR [eax]
	shr	eax, 7

; 685  :     }

	ret	0
?More@COR_ILMETHOD_SECT@@QBE_NXZ ENDP			; COR_ILMETHOD_SECT::More
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetDataSize@tagCOR_ILMETHOD_SECT_FAT@@QBEIXZ
_TEXT	SEGMENT
?GetDataSize@tagCOR_ILMETHOD_SECT_FAT@@QBEIXZ PROC	; tagCOR_ILMETHOD_SECT_FAT::GetDataSize, COMDAT
; _this$ = ecx

; 536  :         /* return DataSize; */
; 537  :         BYTE* p = (BYTE*)this;
; 538  :         return ((unsigned)*(p+1)) |
; 539  :             (((unsigned)*(p+2)) << 8) |
; 540  :             (((unsigned)*(p+3)) << 16);

	movzx	eax, BYTE PTR [ecx+3]
	movzx	edx, BYTE PTR [ecx+2]
	movzx	ecx, BYTE PTR [ecx+1]
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, ecx

; 541  :     }

	ret	0
?GetDataSize@tagCOR_ILMETHOD_SECT_FAT@@QBEIXZ ENDP	; tagCOR_ILMETHOD_SECT_FAT::GetDataSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Data@tagCOR_ILMETHOD_SECT_FAT@@QBEPBEXZ
_TEXT	SEGMENT
?Data@tagCOR_ILMETHOD_SECT_FAT@@QBEPBEXZ PROC		; tagCOR_ILMETHOD_SECT_FAT::Data, COMDAT
; _this$ = eax

; 522  :         return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_FAT)); 

	add	eax, 4

; 523  :     }

	ret	0
?Data@tagCOR_ILMETHOD_SECT_FAT@@QBEPBEXZ ENDP		; tagCOR_ILMETHOD_SECT_FAT::Data
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Data@tagCOR_ILMETHOD_SECT_SMALL@@QBEPBEXZ
_TEXT	SEGMENT
?Data@tagCOR_ILMETHOD_SECT_SMALL@@QBEPBEXZ PROC		; tagCOR_ILMETHOD_SECT_SMALL::Data, COMDAT
; _this$ = eax

; 511  :         return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_SMALL)); 

	add	eax, 2

; 512  :     }

	ret	0
?Data@tagCOR_ILMETHOD_SECT_SMALL@@QBEPBEXZ ENDP		; tagCOR_ILMETHOD_SECT_SMALL::Data
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
_TEXT	ENDS
;	COMDAT ?wcsstr@@YAPA_WPA_WPB_W@Z
_TEXT	SEGMENT
?wcsstr@@YAPA_WPA_WPB_W@Z PROC				; wcsstr, COMDAT
; __Str$ = ecx
; __SubStr$ = eax

; 337  :         {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }

	push	eax
	push	ecx
	call	DWORD PTR __imp__wcsstr
	add	esp, 8
	ret	0
?wcsstr@@YAPA_WPA_WPB_W@Z ENDP				; wcsstr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v6.0a\include\corhlpr.h
;	COMDAT ?GetCode@tagCOR_ILMETHOD_FAT@@QBEPAEXZ
_TEXT	SEGMENT
?GetCode@tagCOR_ILMETHOD_FAT@@QBEPAEXZ PROC		; tagCOR_ILMETHOD_FAT::GetCode, COMDAT
; _this$ = eax

; 944  :         return(((BYTE*) this) + 4*GetSize());

	movzx	ecx, BYTE PTR [eax+1]
	shr	ecx, 4
	lea	eax, DWORD PTR [eax+ecx*4]

; 945  :     }

	ret	0
?GetCode@tagCOR_ILMETHOD_FAT@@QBEPAEXZ ENDP		; tagCOR_ILMETHOD_FAT::GetCode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ
_TEXT	SEGMENT
?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ PROC		; COR_ILMETHOD_SECT_EH::EHCount, COMDAT
; _this$ = eax

; 802  :         return (unsigned)(IsFat() ? (Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) :
; 803  :                         (Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL)));

	test	BYTE PTR [eax], 64			; 00000040H
	je	SHORT $LN3@EHCount
	movzx	ecx, BYTE PTR [eax+3]
	movzx	edx, BYTE PTR [eax+2]
	movzx	eax, BYTE PTR [eax+1]
	shl	ecx, 8
	or	ecx, edx
	shl	ecx, 8
	or	ecx, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	eax, edx
	shr	eax, 4

; 804  :     }

	ret	0
$LN3@EHCount:

; 802  :         return (unsigned)(IsFat() ? (Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) :
; 803  :                         (Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL)));

	movzx	ecx, BYTE PTR [eax+1]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	eax, edx
	shr	eax, 3

; 804  :     }

	ret	0
?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ ENDP		; COR_ILMETHOD_SECT_EH::EHCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Next@COR_ILMETHOD_SECT@@QBEPBU1@XZ
_TEXT	SEGMENT
?Next@COR_ILMETHOD_SECT@@QBEPBU1@XZ PROC		; COR_ILMETHOD_SECT::Next, COMDAT
; _this$ = eax

; 694  :         if (!More()) return(0);

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	js	SHORT $LN2@Next
	xor	eax, eax

; 697  :     }

	ret	0
$LN2@Next:

; 695  :         if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->GetDataSize()])->Align());

	test	cl, 64					; 00000040H
	je	SHORT $LN1@Next
	movzx	ecx, BYTE PTR [eax+3]
	movzx	edx, BYTE PTR [eax+2]
	shl	ecx, 8
	or	ecx, edx
	movzx	edx, BYTE PTR [eax+1]
	shl	ecx, 8
	or	ecx, edx
	lea	eax, DWORD PTR [ecx+eax+7]

; 696  :         return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());

	and	eax, -4					; fffffffcH

; 697  :     }

	ret	0
$LN1@Next:

; 696  :         return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());

	movzx	ecx, BYTE PTR [eax+1]
	lea	eax, DWORD PTR [ecx+eax+5]
	and	eax, -4					; fffffffcH

; 697  :     }

	ret	0
?Next@COR_ILMETHOD_SECT@@QBEPBU1@XZ ENDP		; COR_ILMETHOD_SECT::Next
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = esi

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN12@Dec
	call	edi
$LN12@Dec:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax

; 336  :    				if (_Isnil(_Ptr))

	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LN1@Dec
$LN52@Dec:

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	call	edi
	pop	edi

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN49@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN30@Dec
	npad	8
$LL31@Dec:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL31@Dec
$LN30@Dec:
	mov	DWORD PTR [esi+4], ecx
	pop	edi

; 373  : 				}
; 374  : 			}

	ret	0
$LN49@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN3@Dec
	npad	7
$LL4@Dec:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+29], 0

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else

	jne	SHORT $LN52@Dec

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [esi+4], eax
$LN1@Dec:
	pop	edi

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 286  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIVHandlerInfo@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIVHandlerInfo@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator*, COMDAT
; _this$ = esi

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	test	eax, eax
	jne	SHORT $LN21@operator@18
	call	edi

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@operator@18
$LN21@operator@18:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@18
$LN15@operator@18:
	xor	eax, eax
$LN16@operator@18:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@18
	call	edi
$LN3@operator@18:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 12					; 0000000cH
	pop	edi

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIVHandlerInfo@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
?_Buynode@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Buynode, COMDAT
; __Val$ = esi

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN4@Buynode@8
	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+24], edx
	mov	BYTE PTR [eax+28], cl
	mov	BYTE PTR [eax+29], cl
$LN4@Buynode@8:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	12					; 0000000cH
?_Buynode@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR [edx]
	npad	2
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	0
?_Lbound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator--, COMDAT
; _this$ = eax

; 487  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIVHandlerInfo@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIVHandlerInfo@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator*, COMDAT
; _this$ = esi

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	test	eax, eax
	jne	SHORT $LN23@operator@19
	call	edi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator@19
$LN23@operator@19:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@operator@19
$LN17@operator@19:
	xor	eax, eax
$LN18@operator@19:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN5@operator@19
	call	edi
$LN5@operator@19:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 12					; 0000000cH
	pop	edi

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIVHandlerInfo@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::lower_bound, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = eax

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN5@lower_boun
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp]
	mov	edi, DWORD PTR [edi]
$LL6@lower_boun:
	cmp	DWORD PTR [ecx+12], edi
	jae	SHORT $LN4@lower_boun
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx]
$LN3@lower_boun:
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL6@lower_boun
	pop	edi
$LN5@lower_boun:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::lower_bound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->, COMDAT
; _this$ = esi

; 470  : 			return (&**this);

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	test	eax, eax
	jne	SHORT $LN25@operator@20
	call	edi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN19@operator@20
$LN25@operator@20:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN20@operator@20
$LN19@operator@20:
	xor	eax, eax
$LN20@operator@20:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN7@operator@20
	call	edi
$LN7@operator@20:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 12					; 0000000cH
	pop	edi

; 471  : 			}

	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
__Where$ = -20						; size = 8
$T133775 = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::find, COMDAT
; _this$ = edi

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+4]
	sub	esp, 24					; 00000018H
	cmp	BYTE PTR [eax+29], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Keyval$[esp+28]
	push	esi
	mov	esi, ecx
	jne	SHORT $LN9@find
	mov	ecx, DWORD PTR [ebp]
	npad	5
$LL10@find:
	cmp	DWORD PTR [eax+12], ecx
	jae	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL10@find
$LN9@find:
	mov	eax, DWORD PTR [edi]

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	ebx, DWORD PTR [edi+24]
	mov	DWORD PTR __Where$[esp+40], esi
	mov	DWORD PTR __Where$[esp+36], eax
	test	eax, eax
	je	SHORT $LN68@find
	cmp	eax, eax
	je	SHORT $LN67@find
$LN68@find:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN67@find:
	cmp	esi, ebx
	je	SHORT $LN3@find
	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [esi+12]
	jb	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+36]
	jmp	SHORT $LN4@find
$LN3@find:
	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR $T133775[esp+40], ecx
	mov	DWORD PTR $T133775[esp+36], edx
	lea	eax, DWORD PTR $T133775[esp+36]
$LN4@find:
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	eax, DWORD PTR [eax+4]

; 983  : 		}

	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx
	mov	eax, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::find
_TEXT	ENDS
PUBLIC	?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z ; CProfiler::FixSEHSections
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\profiler.rewriting.cpp
;	COMDAT ?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z
_TEXT	SEGMENT
tv404 = 8						; size = 4
_offset$ = 8						; size = 4
?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z PROC ; CProfiler::FixSEHSections, COMDAT
; _sections$ = eax

; 278  : void CProfiler::FixSEHSections(const COR_ILMETHOD_SECT *sections, int offset) {

	push	ebp
	mov	ebp, DWORD PTR _offset$[esp]
	push	edi
	mov	edi, eax

; 279  :     while (sections) {

	test	edi, edi
	je	$LN60@FixSEHSect
	push	ebx
	push	esi
$LL13@FixSEHSect:

; 280  :         if (sections->Kind() == CorILMethod_Sect_EHTable) {

	mov	al, BYTE PTR [edi]
	mov	cl, al
	and	cl, 63					; 0000003fH
	cmp	cl, 1
	jne	$LN2@FixSEHSect

; 281  :             COR_ILMETHOD_SECT_EH *peh = (COR_ILMETHOD_SECT_EH *) sections;
; 282  : 			if (peh->IsFat()) {
; 283  :                 COR_ILMETHOD_SECT_EH_FAT *pFat = (COR_ILMETHOD_SECT_EH_FAT*) peh;
; 284  : 
; 285  :                 for (unsigned int i = 0;  i < peh->EHCount();  i++) {

	xor	ebx, ebx
	test	al, 64					; 00000040H
	mov	eax, edi
	je	SHORT $LN10@FixSEHSect
	call	?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ	; COR_ILMETHOD_SECT_EH::EHCount
	test	eax, eax
	jbe	SHORT $LN2@FixSEHSect
	lea	esi, DWORD PTR [edi+16]
$LL9@FixSEHSect:

; 286  :                     IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT *pfeh = &pFat->Clauses[i];
; 287  : 
; 288  :                     if (pfeh->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)

	test	BYTE PTR [esi-12], 1
	je	SHORT $LN6@FixSEHSect

; 289  :                         pfeh->FilterOffset += offset;

	add	DWORD PTR [esi+8], ebp
$LN6@FixSEHSect:

; 290  : 
; 291  :                     pfeh->HandlerOffset += offset;

	add	DWORD PTR [esi], ebp

; 292  :                     pfeh->TryOffset += offset;

	add	DWORD PTR [esi-8], ebp
	mov	eax, edi
	inc	ebx
	add	esi, 24					; 00000018H
	call	?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ	; COR_ILMETHOD_SECT_EH::EHCount
	cmp	ebx, eax
	jb	SHORT $LL9@FixSEHSect

; 293  :                 }

	jmp	SHORT $LN2@FixSEHSect
$LN10@FixSEHSect:

; 294  :             } else {
; 295  :                 COR_ILMETHOD_SECT_EH_SMALL *pSmall = (COR_ILMETHOD_SECT_EH_SMALL *) peh;
; 296  : 
; 297  :                 for (unsigned int i = 0;  i < peh->EHCount();  i++) {

	call	?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ	; COR_ILMETHOD_SECT_EH::EHCount
	test	eax, eax
	jbe	SHORT $LN2@FixSEHSect
	mov	ecx, ebp
	shl	ecx, 8
	mov	DWORD PTR tv404[esp+12], ecx
	lea	esi, DWORD PTR [edi+6]
	jmp	SHORT $LN4@FixSEHSect
	npad	4
$LL61@FixSEHSect:
	mov	ecx, DWORD PTR tv404[esp+12]
$LN4@FixSEHSect:

; 298  :                     IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL *pseh = &pSmall->Clauses[i];
; 299  : 
; 300  :                     if (pseh->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)

	test	BYTE PTR [esi-2], 1
	je	SHORT $LN1@FixSEHSect

; 301  :                         pseh->FilterOffset += offset;

	add	DWORD PTR [esi+6], ebp
$LN1@FixSEHSect:

; 302  : 
; 303  :                     pseh->TryOffset += offset;
; 304  :                     pseh->HandlerOffset += offset;

	mov	eax, DWORD PTR [esi+2]
	add	WORD PTR [esi], bp
	mov	edx, eax
	and	edx, -256				; ffffff00H
	add	edx, ecx
	xor	edx, eax
	and	edx, 16776960				; 00ffff00H
	xor	edx, eax
	mov	DWORD PTR [esi+2], edx
	mov	eax, edi
	inc	ebx
	add	esi, 12					; 0000000cH
	call	?EHCount@COR_ILMETHOD_SECT_EH@@QBEIXZ	; COR_ILMETHOD_SECT_EH::EHCount
	cmp	ebx, eax
	jb	SHORT $LL61@FixSEHSect
$LN2@FixSEHSect:

; 305  :                 }
; 306  :             }
; 307  :         }
; 308  :         sections = sections->Next();

	mov	al, BYTE PTR [edi]
	test	al, al
	jns	SHORT $LN62@FixSEHSect
	test	al, 64					; 00000040H
	je	SHORT $LN24@FixSEHSect
	movzx	eax, BYTE PTR [edi+3]
	movzx	ecx, BYTE PTR [edi+2]
	movzx	edx, BYTE PTR [edi+1]
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	lea	edi, DWORD PTR [eax+edi+7]
	jmp	SHORT $LN64@FixSEHSect
$LN24@FixSEHSect:
	movzx	eax, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [eax+edi+5]
$LN64@FixSEHSect:
	and	edi, -4					; fffffffcH
	test	edi, edi
	jne	$LL13@FixSEHSect
$LN62@FixSEHSect:
	pop	esi
	pop	ebx
$LN60@FixSEHSect:
	pop	edi
	pop	ebp

; 309  :     } 
; 310  : }

	ret	4
?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z ENDP ; CProfiler::FixSEHSections
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v6.0a\include\corhlpr.h
_TEXT	ENDS
;	COMDAT ?GetSect@tagCOR_ILMETHOD_FAT@@QBEPBUCOR_ILMETHOD_SECT@@XZ
_TEXT	SEGMENT
?GetSect@tagCOR_ILMETHOD_FAT@@QBEPBUCOR_ILMETHOD_SECT@@XZ PROC ; tagCOR_ILMETHOD_FAT::GetSect, COMDAT
; _this$ = eax

; 948  :         /* if (!(GetFlags() & CorILMethod_MoreSects)) return(0); */
; 949  :         if (!(*(BYTE*)this & CorILMethod_MoreSects)) return (0);

	test	BYTE PTR [eax], 8
	jne	SHORT $LN1@GetSect
	xor	eax, eax

; 951  :     }

	ret	0
$LN1@GetSect:

; 950  :         return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());

	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR [eax+4]
	shr	ecx, 4
	lea	ecx, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [ecx+eax+3]
	and	eax, -4					; fffffffcH

; 951  :     }

	ret	0
?GetSect@tagCOR_ILMETHOD_FAT@@QBEPBUCOR_ILMETHOD_SECT@@XZ ENDP ; tagCOR_ILMETHOD_FAT::GetSect
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z
_TEXT	SEGMENT
$T150582 = -80						; size = 28
$T150581 = -52						; size = 40
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Insert, COMDAT
; __Wherenode$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+84]

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [ebx+28], 268435454		; 0ffffffeH
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T150582[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T150582[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T150581[esp+104]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	edx, DWORD PTR $T150581[esp+104]
	push	edx
	call	__CxxThrowException@8
$LN381@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR __Val$[esp+96]
	push	eax
	push	edi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIVHandlerInfo@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Buynode

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR [ebx+24]
	inc	DWORD PTR [ebx+28]
	mov	ebp, eax
	xor	al, al
	cmp	edi, ecx
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [ecx], ebp
	mov	edx, DWORD PTR [ebx+24]
	mov	DWORD PTR [edx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+96], al
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR [ebx+24]
	cmp	edi, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR [ebx+24]
	cmp	edi, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+4]
	mov	edx, ebp
	cmp	BYTE PTR [esi+28], al
	jne	$LN9@Insert
	npad	1
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+4]
	cmp	esi, DWORD PTR [edi]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edi, DWORD PTR [edi+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edi+28], al
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, esi
	mov	BYTE PTR [edx+28], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edi+28], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+4]
	mov	BYTE PTR [edx+28], al

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN311@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	edx, DWORD PTR [esi+8]
	jne	SHORT $LN106@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	edx, esi

; 1228 : 						_Lrotate(_Pnode);

	mov	esi, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+29], al
	jne	SHORT $LN105@Insert
	mov	DWORD PTR [ecx+4], edx
$LN105@Insert:
	mov	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+24]
	cmp	edx, DWORD PTR [edi+4]
	jne	SHORT $LN104@Insert
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $LN101@Insert
$LN104@Insert:
	mov	edi, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [edi]
	jne	SHORT $LN102@Insert
	mov	DWORD PTR [edi], esi
	jmp	SHORT $LN101@Insert
$LN102@Insert:
	mov	DWORD PTR [edi+8], esi
$LN101@Insert:
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ecx], esi
$LN106@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	esi, DWORD PTR [ecx]
	mov	BYTE PTR [esi+28], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	esi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+28], al

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [esi+8]
	cmp	BYTE PTR [edi+29], al
	jne	SHORT $LN168@Insert
	mov	DWORD PTR [edi+4], ecx
$LN168@Insert:
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+24]
	cmp	ecx, DWORD PTR [edi+4]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [esi+8], ecx

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN380@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN167@Insert:
	mov	edi, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edi+8]
	jne	SHORT $LN165@Insert
	mov	DWORD PTR [edi+8], esi
	mov	DWORD PTR [esi+8], ecx

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN380@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN165@Insert:
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [esi+8], ecx

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN380@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edi, DWORD PTR [edi]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edi+28], al
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, esi
	mov	BYTE PTR [edx+28], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edi+28], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+4]
	mov	BYTE PTR [edx+28], al

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	$LN311@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	edx, DWORD PTR [esi]
	jne	SHORT $LN248@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, esi

; 1250 : 						_Rrotate(_Pnode);

	mov	esi, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi+8]
	cmp	BYTE PTR [ecx+29], al
	jne	SHORT $LN247@Insert
	mov	DWORD PTR [ecx+4], edx
$LN247@Insert:
	mov	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+24]
	cmp	edx, DWORD PTR [edi+4]
	jne	SHORT $LN246@Insert
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $LN243@Insert
$LN246@Insert:
	mov	edi, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [edi+8]
	jne	SHORT $LN244@Insert
	mov	DWORD PTR [edi+8], esi
	jmp	SHORT $LN243@Insert
$LN244@Insert:
	mov	DWORD PTR [edi], esi
$LN243@Insert:
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [ecx], esi
$LN248@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	esi, DWORD PTR [ecx]
	mov	BYTE PTR [esi+28], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	esi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+28], al

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [esi]
	cmp	BYTE PTR [edi+29], al
	jne	SHORT $LN310@Insert
	mov	DWORD PTR [edi+4], ecx
$LN310@Insert:
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+24]
	cmp	ecx, DWORD PTR [edi+4]
	jne	SHORT $LN309@Insert
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $LN306@Insert
$LN309@Insert:
	mov	edi, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edi]
	jne	SHORT $LN307@Insert
	mov	DWORD PTR [edi], esi
	jmp	SHORT $LN306@Insert
$LN307@Insert:
	mov	DWORD PTR [edi+8], esi
$LN306@Insert:
	mov	DWORD PTR [esi], ecx
$LN380@Insert:
	mov	DWORD PTR [ecx+4], esi
$LN311@Insert:
	mov	esi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [esi+28], al
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+28], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]

; 1260 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN379@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z$0:
	lea	ecx, DWORD PTR $T150582[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z
_TEXT	SEGMENT
$T151380 = -12						; size = 8
$T151378 = -12						; size = 8
__Where$101153 = -12					; size = 8
__Addleft$ = 8						; size = 1
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::insert, COMDAT
; ___$ReturnUdt$ = edi

; 630  : 		{	// try to insert node with value _Val

	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+16]
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ebp, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebp+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+29], 0
	mov	cl, 1
	push	esi
	mov	BYTE PTR __Addleft$[esp+24], cl
	jne	SHORT $LN9@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	edx, DWORD PTR [ecx]
$LL10@insert:
	cmp	edx, DWORD PTR [eax+12]
	mov	ebp, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+24], cl
	test	cl, cl
	je	SHORT $LN13@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,
; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	eax, DWORD PTR [ebx]
	mov	edx, ebp
	mov	DWORD PTR __Where$101153[esp+32], edx
	mov	DWORD PTR __Where$101153[esp+28], eax

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN90@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	edx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN78@insert
	cmp	eax, eax
	je	SHORT $LN77@insert
$LN78@insert:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN77@insert:
	cmp	ebp, esi
	jne	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	eax, DWORD PTR __Val$[esp+24]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T151378[esp+36]
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi], edx
	mov	BYTE PTR [edi+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, edi

; 659  : 			}
; 660  : 		}

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	lea	esi, DWORD PTR __Where$101153[esp+28]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$101153[esp+32]
	mov	eax, DWORD PTR __Where$101153[esp+28]
$LN90@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Val$[esp+24]
	cmp	esi, DWORD PTR [ecx]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	push	ecx
	mov	ecx, DWORD PTR __Addleft$[esp+28]
	push	ecx
	lea	edx, DWORD PTR $T151380[esp+36]
	push	edx
	push	ebx
	mov	ecx, ebp
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi], ecx
	mov	BYTE PTR [edi+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [edi+4], edx
	mov	eax, edi

; 659  : 			}
; 660  : 		}

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN2@insert:
	pop	esi
	pop	ebp
	mov	DWORD PTR [edi], eax
	mov	BYTE PTR [edi+8], 0
	mov	DWORD PTR [edi+4], edx
	mov	eax, edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::insert
_TEXT	ENDS
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\profiler.rewriting.cpp
;	COMDAT ?ModuleLoadFinished@CProfiler@@UAGJIJ@Z
_TEXT	SEGMENT
_pIMetaDataEmit$ = -4160				; size = 4
_asmMetaData$ = -4156					; size = 4
_moduleRef$ = -4152					; size = 4
_actualLen$ = -4148					; size = 4
_logger$ = -4144					; size = 4
_activator$ = -4140					; size = 4
$T151624 = -4136					; size = 16
$T151623 = -4136					; size = 8
_assemblyID$ = -4120					; size = 4
tv412 = -4116						; size = 4
_deactivator$ = -4112					; size = 4
$T151627 = -4108					; size = 12
_it$99431 = -4108					; size = 8
_assemblyName$ = -4096					; size = 2048
_moduleName$ = -2048					; size = 2048
_this$ = 8						; size = 4
_moduleID$ = 12						; size = 4
___formal$ = 16						; size = 4
?ModuleLoadFinished@CProfiler@@UAGJIJ@Z PROC		; CProfiler::ModuleLoadFinished, COMDAT

; 326  : STDMETHODIMP CProfiler::ModuleLoadFinished(ModuleID moduleID, HRESULT /*hrStatus*/) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, 4164				; 00001044H
	call	__chkstk
	push	ebx
	push	esi
	push	edi

; 327  : 	HRESULT hr = S_OK;
; 328  : 	
; 329  : 	IMetaDataEmit *pIMetaDataEmit = nullptr;
; 330  : 	IMetaDataAssemblyImport *asmMetaData = nullptr;
; 331  : 	
; 332  : 	WCHAR moduleName[NAME_BUFFER_SIZE];
; 333  : 	WCHAR assemblyName[NAME_BUFFER_SIZE];
; 334  : 	
; 335  : 	AssemblyID assemblyID;
; 336  : 	
; 337  : 	ULONG actualLen = 0;
; 338  : 	
; 339  : 	hr = pICorProfilerInfo->GetModuleInfo(moduleID, nullptr, NAME_BUFFER_SIZE, &actualLen, moduleName, &assemblyID);

	mov	edi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR _assemblyID$[esp+4176]
	push	edx
	lea	edx, DWORD PTR _moduleName$[esp+4180]
	push	edx
	lea	edx, DWORD PTR _actualLen$[esp+4184]
	push	edx
	mov	edx, DWORD PTR _moduleID$[ebp]
	xor	ebx, ebx
	push	1024					; 00000400H
	push	ebx
	mov	DWORD PTR _pIMetaDataEmit$[esp+4196], ebx
	mov	DWORD PTR _asmMetaData$[esp+4196], ebx
	mov	DWORD PTR _actualLen$[esp+4196], ebx
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+80]
	call	eax

; 340  : 	
; 341  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$CLEANUP$99381

; 342  : 		goto CLEANUP;
; 343  : 	
; 344  : 	hr = pICorProfilerInfo->GetAssemblyInfo(assemblyID, NAME_BUFFER_SIZE, &actualLen, assemblyName, nullptr, nullptr);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	ebx
	lea	edx, DWORD PTR _assemblyName$[esp+4184]
	push	edx
	lea	edx, DWORD PTR _actualLen$[esp+4188]
	push	edx
	mov	edx, DWORD PTR _assemblyID$[esp+4192]
	push	1024					; 00000400H
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+104]
	call	eax

; 345  : 	
; 346  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$CLEANUP$99381

; 347  : 		goto CLEANUP;
; 348  : 	
; 349  : 	DebugWriteLine(L"\n----------------- Module Load finished -----------------\n");
; 350  : 	DebugWriteLine(L"Module Name: '%s'\n", moduleName);
; 351  : 	DebugWriteLine(L"Assembly Name: '%s'\n", assemblyName);
; 352  : 	DebugWriteLine(L"--------------------------------------------------------\n");
; 353  : 	
; 354  : 	bool found = false;
; 355  : 	
; 356  : 	for (int i = 0; i < ASSEMBLY_INJECTION_NAME_LIST_LENGTH; i++) {

	mov	esi, OFFSET ?assemblyInjectionNameList@@3PAPA_WA ; assemblyInjectionNameList
$LL25@ModuleLoad:

; 357  : 		if (wcscmp(assemblyInjectionNameList[i], assemblyName) == 0) {

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _assemblyName$[esp+4176]
$LL64@ModuleLoad:
	mov	dx, WORD PTR [eax]
	cmp	dx, WORD PTR [ecx]
	jne	SHORT $LN65@ModuleLoad
	cmp	dx, bx
	je	SHORT $LN66@ModuleLoad
	mov	dx, WORD PTR [eax+2]
	cmp	dx, WORD PTR [ecx+2]
	jne	SHORT $LN65@ModuleLoad
	add	eax, 4
	add	ecx, 4
	cmp	dx, bx
	jne	SHORT $LL64@ModuleLoad
$LN66@ModuleLoad:
	xor	eax, eax
	jmp	SHORT $LN67@ModuleLoad
$LN65@ModuleLoad:
	sbb	eax, eax
	sbb	eax, -1
$LN67@ModuleLoad:
	cmp	eax, ebx
	je	SHORT $LN61@ModuleLoad
	add	esi, 4
	cmp	esi, OFFSET ?assemblyInjectionNameList@@3PAPA_WA+12
	jl	SHORT $LL25@ModuleLoad
	jmp	$CLEANUP$99381
$LN61@ModuleLoad:

; 358  : 			found = true;
; 359  : 			break;
; 360  : 		}
; 361  : 	}
; 362  : 	
; 363  : 	if (!found) {
; 364  : 		DebugWriteLine(L"Assembly Name '%s' not found in list!\n", assemblyName);
; 365  : 		goto CLEANUP;
; 366  : 	}
; 367  : 	
; 368  : 	hr = pICorProfilerInfo->GetModuleMetaData(moduleID, ofRead | ofWrite, IID_IMetaDataEmit, (LPUNKNOWN *) &pIMetaDataEmit);

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _moduleID$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _pIMetaDataEmit$[esp+4176]
	push	edx
	push	OFFSET _IID_IMetaDataEmit
	push	1
	push	esi
	push	eax
	mov	eax, DWORD PTR [ecx+84]
	call	eax

; 369  : 		
; 370  : 	if (!SUCCEEDED(hr) || pIMetaDataEmit == nullptr)

	test	eax, eax
	jl	$CLEANUP$99381
	cmp	DWORD PTR _pIMetaDataEmit$[esp+4176], ebx
	je	$LN2@ModuleLoad

; 371  : 		goto CLEANUP;
; 372  : 	
; 373  : 	hr = pICorProfilerInfo->GetModuleMetaData(moduleID, ofRead | ofWrite, IID_IMetaDataAssemblyImport, (LPUNKNOWN *) &asmMetaData);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _asmMetaData$[esp+4176]
	push	edx
	push	OFFSET _IID_IMetaDataAssemblyImport
	push	1
	push	esi
	push	eax
	mov	eax, DWORD PTR [ecx+84]
	call	eax

; 374  : 
; 375  : 	if (!SUCCEEDED(hr) || asmMetaData == nullptr)

	test	eax, eax
	jl	$CLEANUP$99381
	cmp	DWORD PTR _asmMetaData$[esp+4176], ebx
	je	$CLEANUP$99381

; 376  : 		goto CLEANUP;
; 377  : 		
; 378  : 	mdToken moduleRef;
; 379  : 	hr = pIMetaDataEmit->DefineModuleRef(HOOK_MODULE_NAME, &moduleRef);

	mov	eax, DWORD PTR _pIMetaDataEmit$[esp+4176]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _moduleRef$[esp+4176]
	push	edx
	push	OFFSET ??_C@_1BG@CBDINCKK@?$AAH?$AAo?$AAo?$AAk?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	push	eax
	mov	eax, DWORD PTR [ecx+96]
	call	eax

; 380  : 	
; 381  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$CLEANUP$99381

; 382  : 		goto CLEANUP;
; 383  : 		
; 384  : 	mdMethodDef deactivator;
; 385  : 	if (!CreateMethod(pIMetaDataEmit, L"DeactivateProfiler", rgSig, &deactivator, moduleRef))

	mov	ecx, DWORD PTR _moduleRef$[esp+4176]
	mov	esi, DWORD PTR _pIMetaDataEmit$[esp+4176]
	push	ecx
	push	OFFSET ??_C@_1CG@IGFKGMEH@?$AAD?$AAe?$AAa?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@
	lea	edi, DWORD PTR _deactivator$[esp+4184]
	call	?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z ; CProfiler::CreateMethod
	test	al, al
	je	$CLEANUP$99381

; 386  : 		goto CLEANUP;
; 387  : 		
; 388  : 	mdMethodDef activator;
; 389  : 	if (!CreateMethod(pIMetaDataEmit, L"ActivateProfiler", rgSig, &activator, moduleRef))

	mov	edx, DWORD PTR _moduleRef$[esp+4176]
	mov	esi, DWORD PTR _pIMetaDataEmit$[esp+4176]
	push	edx
	push	OFFSET ??_C@_1CC@HDGCFJKN@?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAe?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?$AA@
	lea	edi, DWORD PTR _activator$[esp+4184]
	call	?CreateMethod@CProfiler@@AAE_NPAUIMetaDataEmit@@PB_WPBEPAII@Z ; CProfiler::CreateMethod
	test	al, al
	je	$CLEANUP$99381

; 390  : 		goto CLEANUP;
; 391  : 
; 392  : 	mdMethodDef logger;
; 393  : 	hr = pIMetaDataEmit->DefineMethod(mdTokenNil, L"LogEvent", mdPublic | mdStatic | mdPinvokeImpl, loggerSig, sizeof(loggerSig), 0, miIL | miManaged, &logger);

	mov	eax, DWORD PTR _pIMetaDataEmit$[esp+4176]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _logger$[esp+4176]
	push	edx
	push	ebx
	push	ebx
	push	7
	push	OFFSET _loggerSig
	push	8214					; 00002016H
	push	OFFSET ??_C@_1BC@HNBEDEIN@?$AAL?$AAo?$AAg?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
	push	ebx
	push	eax
	mov	eax, DWORD PTR [ecx+40]
	call	eax

; 394  : 	
; 395  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$CLEANUP$99381

; 396  : 		goto CLEANUP;
; 397  : 		
; 398  : 	hr = pIMetaDataEmit->DefinePinvokeMap(logger, pmNoMangle | pmCallConvStdcall | pmCharSetUnicode, L"LogEvent", moduleRef);

	mov	edx, DWORD PTR _moduleRef$[esp+4176]
	mov	eax, DWORD PTR _pIMetaDataEmit$[esp+4176]
	mov	ecx, DWORD PTR [eax]
	push	edx
	mov	edx, DWORD PTR _logger$[esp+4180]
	push	OFFSET ??_C@_1BC@HNBEDEIN@?$AAL?$AAo?$AAg?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
	push	773					; 00000305H
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+136]
	call	eax

; 399  : 	
; 400  : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$CLEANUP$99381

; 401  : 		goto CLEANUP;
; 402  : 	
; 403  : 	{
; 404  : 		methodMapCriticalSection.Enter();

	mov	ebx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ebx+116]
	push	eax
	mov	DWORD PTR tv412[esp+4180], eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 405  : 		TMethodTokenMap::iterator it = this->methodMap.find(moduleID);

	lea	ecx, DWORD PTR _moduleID$[ebp]
	push	ecx
	lea	edx, DWORD PTR _it$99431[esp+4180]
	add	ebx, 244				; 000000f4H
	push	edx
	mov	edi, ebx
	call	?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::find

; 406  : 		if (it == this->methodMap.end()) {

	mov	eax, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [ebx]
	lea	esi, DWORD PTR $T151623[esp+4176]
	lea	edi, DWORD PTR _it$99431[esp+4176]
	mov	DWORD PTR $T151623[esp+4180], eax
	mov	DWORD PTR $T151623[esp+4176], ecx
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator==
	test	al, al
	je	SHORT $LN3@ModuleLoad

; 407  : 			this->methodMap.insert(TMethodTokenPair(moduleID, HandlerInfo(activator, deactivator, logger)));

	mov	edx, DWORD PTR _logger$[esp+4176]
	mov	eax, DWORD PTR _activator$[esp+4176]
	mov	ecx, DWORD PTR _deactivator$[esp+4176]
	mov	esi, DWORD PTR _moduleID$[ebp]
	mov	DWORD PTR $T151624[esp+4188], edx
	lea	edx, DWORD PTR $T151624[esp+4176]
	push	edx
	push	ebx
	lea	edi, DWORD PTR $T151627[esp+4184]
	mov	DWORD PTR $T151624[esp+4184], esi
	mov	DWORD PTR $T151624[esp+4188], ecx
	mov	DWORD PTR $T151624[esp+4192], eax
	call	?insert@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIVHandlerInfo@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::insert
$LN3@ModuleLoad:

; 408  : 		}
; 409  : 		methodMapCriticalSection.Leave();

	mov	eax, DWORD PTR tv412[esp+4176]
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4
	xor	ebx, ebx
$CLEANUP$99381:

; 410  : 	}
; 411  : 	
; 412  : CLEANUP:
; 413  : 	#ifdef DEBUG
; 414  : 	if (!SUCCEEDED(hr)) {
; 415  : 		MessageBox(nullptr, TEXT("Crashed in ModuleLoadFinished"), TEXT("Crash!"), MB_OK);
; 416  : 		__debugbreak();
; 417  : 	}
; 418  : 	#endif
; 419  : 	
; 420  : 	if (pIMetaDataEmit != nullptr)

	mov	eax, DWORD PTR _pIMetaDataEmit$[esp+4176]
	cmp	eax, ebx
	je	SHORT $LN2@ModuleLoad

; 421  : 		pIMetaDataEmit->Release();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN2@ModuleLoad:

; 422  : 	
; 423  : 	if (asmMetaData != nullptr)

	mov	eax, DWORD PTR _asmMetaData$[esp+4176]
	cmp	eax, ebx
	je	SHORT $LN68@ModuleLoad

; 424  : 		asmMetaData->Release();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN68@ModuleLoad:

; 425  : 	
; 426  : 	return S_OK;
; 427  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ModuleLoadFinished@CProfiler@@UAGJIJ@Z ENDP		; CProfiler::ModuleLoadFinished
_TEXT	ENDS
PUBLIC	?Rewrite@CProfiler@@AAEXIHH@Z			; CProfiler::Rewrite
; Function compile flags: /Ogtpy
;	COMDAT ?Rewrite@CProfiler@@AAEXIHH@Z
_TEXT	SEGMENT
_header$ = -112						; size = 4
_moduleID$ = -108					; size = 4
_allocator$ = -104					; size = 4
_activateCall$ = -100					; size = 4
_metaData$ = -96					; size = 4
_newLength$ = -92					; size = 4
_deactivateCall$ = -92					; size = 4
_token$ = -88						; size = 4
_it$ = -84						; size = 8
$T151731 = -76						; size = 8
_newCode$ = -68						; size = 64
_this$ = 8						; size = 4
_length$ = 12						; size = 4
_functionID$ = 12					; size = 4
_type$ = 16						; size = 4
_nameId$ = 20						; size = 4
?Rewrite@CProfiler@@AAEXIHH@Z PROC			; CProfiler::Rewrite, COMDAT

; 35   : void CProfiler::Rewrite(FunctionID functionID, int type, int nameId) {

	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp

; 36   : 	ModuleID moduleID;
; 37   : 	mdToken token;
; 38   : 	HRESULT hr = S_OK;
; 39   : 	
; 40   : 	hr = pICorProfilerInfo2->GetFunctionInfo(functionID, 0, &moduleID, &token);

	mov	ebp, DWORD PTR _this$[esp+120]
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	edi
	lea	edx, DWORD PTR _token$[esp+132]
	push	edx
	lea	edx, DWORD PTR _moduleID$[esp+136]
	push	edx
	mov	edx, DWORD PTR _functionID$[esp+136]
	xor	esi, esi
	push	esi
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+60]
	call	eax

; 41   : 	
; 42   : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$LN9@Rewrite

; 43   : 		return;
; 44   : 	
; 45   : 	LPCBYTE header;
; 46   : 	ULONG length;
; 47   : 
; 48   : 	hr = pICorProfilerInfo2->GetILFunctionBody(moduleID, token, &header, &length);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _length$[esp+128]
	push	edx
	lea	edx, DWORD PTR _header$[esp+136]
	push	edx
	mov	edx, DWORD PTR _token$[esp+140]
	push	edx
	mov	edx, DWORD PTR _moduleID$[esp+144]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+88]
	call	eax

; 49   : 	
; 50   : 	if (!SUCCEEDED(hr))

	test	eax, eax
	jl	$LN9@Rewrite

; 51   : 		return;
; 52   : 		
; 53   : 	IMethodMalloc *allocator = nullptr;
; 54   : 	
; 55   : 	hr = pICorProfilerInfo2->GetILFunctionBodyAllocator(moduleID, &allocator);

	mov	eax, DWORD PTR [ebp+8]
	lea	edx, DWORD PTR _allocator$[esp+132]
	push	edx
	mov	edx, DWORD PTR _moduleID$[esp+136]
	mov	DWORD PTR _allocator$[esp+136], esi
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+92]
	call	eax

; 56   : 	
; 57   : 	if (!SUCCEEDED(hr) || allocator == nullptr)

	test	eax, eax
	jl	$LN9@Rewrite
	cmp	DWORD PTR _allocator$[esp+132], esi
	je	$LN9@Rewrite

; 58   : 		return;
; 59   : 	
; 60   : 	methodMapCriticalSection.Enter();

	lea	ebx, DWORD PTR [ebp+116]
	push	ebx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 61   : 	TMethodTokenMap::iterator it = this->methodMap.find(moduleID);

	lea	ecx, DWORD PTR _moduleID$[esp+132]
	push	ecx
	lea	edx, DWORD PTR _it$[esp+136]
	lea	edi, DWORD PTR [ebp+244]
	push	edx
	call	?find@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::find

; 62   : 	
; 63   : 	mdMethodDef deactivateCall = nullptr;
; 64   : 	mdMethodDef activateCall = nullptr;
; 65   : 	mdMethodDef loggerCall = nullptr;
; 66   : 	
; 67   : 	if (it != this->methodMap.end()) {

	mov	eax, DWORD PTR [edi+24]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR $T151731[esp+136], eax
	mov	eax, DWORD PTR _it$[esp+132]
	mov	DWORD PTR _deactivateCall$[esp+132], esi
	mov	DWORD PTR _activateCall$[esp+132], esi
	test	eax, eax
	je	SHORT $LN47@Rewrite
	cmp	eax, edi
	je	SHORT $LN46@Rewrite
$LN47@Rewrite:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN46@Rewrite:
	mov	ecx, DWORD PTR $T151731[esp+136]
	cmp	DWORD PTR _it$[esp+136], ecx
	je	SHORT $LN13@Rewrite

; 68   : 		deactivateCall = it->second.deactivator;

	lea	esi, DWORD PTR _it$[esp+132]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _deactivateCall$[esp+132], edx

; 69   : 		activateCall = it->second.activator;

	call	??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _activateCall$[esp+132], eax

; 70   : 		loggerCall = it->second.logger;

	call	??Citerator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBIVHandlerInfo@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::operator->
	mov	esi, DWORD PTR [eax+12]
$LN13@Rewrite:

; 71   : 	}
; 72   : 	
; 73   : 	methodMapCriticalSection.Leave();

	push	ebx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 74   : 	
; 75   : 	if (deactivateCall == nullptr || activateCall == nullptr || loggerCall == nullptr)

	mov	ebx, DWORD PTR _deactivateCall$[esp+132]
	xor	edi, edi
	cmp	ebx, edi
	je	$LN9@Rewrite
	cmp	DWORD PTR _activateCall$[esp+132], edi
	je	$LN9@Rewrite
	cmp	esi, edi
	je	$LN9@Rewrite

; 76   : 		return;
; 77   : 		
; 78   : 	IMetaDataImport *metaData = nullptr;
; 79   : 	hr = pICorProfilerInfo->GetModuleMetaData(moduleID, ofRead, IID_IMetaDataImport, (LPUNKNOWN *) &metaData);

	mov	ebp, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR _moduleID$[esp+132]
	lea	edx, DWORD PTR _metaData$[esp+132]
	push	edx
	push	OFFSET _IID_IMetaDataImport
	push	edi
	mov	DWORD PTR _metaData$[esp+144], edi
	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+84]
	push	eax
	push	ebp
	call	ecx

; 80   : 
; 81   : 	if (!SUCCEEDED(hr) || metaData == nullptr)

	test	eax, eax
	jl	$LN9@Rewrite
	cmp	DWORD PTR _metaData$[esp+132], edi
	je	$LN9@Rewrite

; 82   : 		return;
; 83   : 
; 84   : 	byte *codeBuf = 0;
; 85   : 	
; 86   : 	codeBuf = (byte *)allocator->Alloc(length + 128);

	mov	ecx, DWORD PTR _length$[esp+128]
	mov	eax, DWORD PTR _allocator$[esp+132]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+12]
	sub	ecx, -128				; ffffff80H
	push	ecx
	push	eax
	call	edx
	mov	ebp, eax

; 87   :     allocator->Release(); 

	mov	eax, DWORD PTR _allocator$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 88   : 	
; 89   : 	if (codeBuf == nullptr)

	cmp	ebp, edi
	je	$LN9@Rewrite

; 90   : 		return;
; 91   : 	
; 92   : 	int newLength = 0;
; 93   : 	
; 94   : 	unsigned char newCode[64] = { 0 };

	push	63					; 0000003fH
	lea	eax, DWORD PTR _newCode$[esp+137]
	push	edi
	push	eax
	mov	DWORD PTR _newLength$[esp+144], edi
	mov	BYTE PTR _newCode$[esp+144], 0
	call	_memset

; 95   : 	
; 96   : 	int injectionLen = SetInjectionCode(metaData, newCode, &newLength, activateCall, loggerCall, deactivateCall, type, nameId);

	mov	ecx, DWORD PTR _nameId$[esp+140]
	mov	edx, DWORD PTR _activateCall$[esp+144]
	mov	eax, DWORD PTR _metaData$[esp+144]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _type$[esp+132]
	push	esi
	push	edx
	push	eax
	mov	edx, ebx
	lea	edi, DWORD PTR _newLength$[esp+148]
	lea	esi, DWORD PTR _newCode$[esp+148]
	call	?SetInjectionCode@CProfiler@@AAEHPAUIMetaDataImport@@PAEPAHIIIHH@Z ; CProfiler::SetInjectionCode

; 97   : 	
; 98   : 	assert(injectionLen == newLength);
; 99   : 	
; 100  : 	DebugWriteLine(L"rewrite size %d", injectionLen);
; 101  : 
; 102  : 	if (((COR_ILMETHOD_TINY *)header)->IsTiny()) {

	mov	ecx, DWORD PTR _header$[esp+132]
	mov	esi, eax
	mov	al, BYTE PTR [ecx]
	mov	dl, al
	and	dl, 3
	cmp	dl, 2
	jne	$LN7@Rewrite

; 103  : 	    COR_ILMETHOD_TINY *method = (COR_ILMETHOD_TINY *)header;
; 104  : 
; 105  : 		if (method->GetCodeSize() + injectionLen < MAX_CODE_SIZE_TINY) {

	movzx	ecx, al
	shr	ecx, 2
	add	ecx, esi

; 106  : 			DebugWriteLine(L"rewrite normal");
; 107  : 			// Copy the header elements.
; 108  : 			memcpy(&codeBuf[0], method, TINY_HEADER_SIZE);
; 109  : 			newLength = TINY_HEADER_SIZE;
; 110  : 			
; 111  : 			// copy new code
; 112  : 			memcpy(&codeBuf[newLength],
; 113  : 					&newCode[0],
; 114  : 					injectionLen);

	push	esi
	lea	edx, DWORD PTR _newCode$[esp+136]
	push	edx
	cmp	ecx, 64					; 00000040H
	jae	SHORT $LN6@Rewrite
	mov	BYTE PTR [ebp], al
	lea	eax, DWORD PTR [ebp+1]
	push	eax
	call	_memcpy

; 115  : 					
; 116  : 			newLength += injectionLen;
; 117  : 			
; 118  : 			// copy old code
; 119  : 			memcpy(&codeBuf[newLength],
; 120  : 					&header[TINY_HEADER_SIZE],
; 121  : 					length - TINY_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	mov	edx, DWORD PTR _header$[esp+144]
	add	esp, 12					; 0000000cH
	dec	ecx
	push	ecx
	inc	edx
	push	edx
	lea	eax, DWORD PTR [esi+ebp+1]
	push	eax
	call	_memcpy

; 122  : 			
; 123  : 			newLength += (length - TINY_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	lea	ebx, DWORD PTR [esi+ecx]

; 124  : 			
; 125  : 			// update code size in header
; 126  : 			// LLLLLLUU
; 127  : 			// 2 upper bits are the tiny header 6 lower bits are length
; 128  : 			codeBuf[0] = (byte)((newLength - 1) << 2 | 0x2); 

	mov	dl, bl
	dec	dl
	add	dl, dl
	add	dl, dl
	add	esp, 12					; 0000000cH
	or	dl, 2
	mov	BYTE PTR [ebp], dl

; 129  :         } else {

	jmp	$LN3@Rewrite
$LN6@Rewrite:

; 130  :         	DebugWriteLine(L"rewrite convert");
; 131  : 			ConvertToFat((byte *)codeBuf, &newLength);

	xor	eax, eax
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	eax, DWORD PTR [ebp]
	and	eax, -53245				; ffff3003H
	or	eax, 12291				; 00003003H
	mov	DWORD PTR [ebp], eax

; 132  : 			
; 133  : 			// copy new code
; 134  : 			memcpy(&codeBuf[newLength],
; 135  : 					&newCode[0],
; 136  : 					injectionLen);

	lea	eax, DWORD PTR [ebp+12]
	mov	ecx, 8
	push	eax
	mov	WORD PTR [ebp+2], cx
	call	_memcpy

; 137  : 			
; 138  : 			newLength += injectionLen;
; 139  : 						
; 140  : 			// copy old code
; 141  : 			memcpy(&codeBuf[newLength], &header[TINY_HEADER_SIZE], length - TINY_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	mov	edx, DWORD PTR _header$[esp+144]
	add	esp, 12					; 0000000cH
	dec	ecx
	push	ecx
	inc	edx
	push	edx
	lea	eax, DWORD PTR [esi+ebp+12]
	push	eax
	call	_memcpy

; 142  : 			newLength += (length - TINY_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	lea	ebx, DWORD PTR [esi+ecx+11]

; 143  : 			
; 144  : 			COR_ILMETHOD_FAT *target = (COR_ILMETHOD_FAT *)codeBuf;
; 145  : 			target->CodeSize = newLength - FAT_HEADER_SIZE;

	lea	edx, DWORD PTR [ebx-12]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp+4], edx

; 146  :         }

	jmp	$LN3@Rewrite
$LN7@Rewrite:

; 147  : 	} else if (((COR_ILMETHOD_FAT *)header)->IsFat()) {

	and	al, 7
	cmp	al, 3
	jne	$LN76@Rewrite

; 148  : 		DebugWriteLine(L"rewrite fat");
; 149  : 		COR_ILMETHOD_FAT *method = (COR_ILMETHOD_FAT *)header;
; 150  : 		COR_ILMETHOD_FAT *target = (COR_ILMETHOD_FAT *)codeBuf;
; 151  : 		
; 152  : 		// Copy the header elements.
; 153  : 		newLength = FAT_HEADER_SIZE;
; 154  : 		memcpy(&codeBuf[0], method, newLength);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ebp], eax
	mov	edi, ecx
	mov	ecx, DWORD PTR _header$[esp+132]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebp+4], edx
	mov	eax, DWORD PTR _header$[esp+132]
	mov	ecx, DWORD PTR [eax+8]

; 155  : 
; 156  : 		// copy new code
; 157  : 		memcpy(&codeBuf[newLength],
; 158  : 				&newCode[0],
; 159  : 				injectionLen);

	push	esi
	lea	edx, DWORD PTR _newCode$[esp+136]
	push	edx
	lea	eax, DWORD PTR [ebp+12]
	push	eax
	mov	DWORD PTR [ebp+8], ecx
	call	_memcpy

; 160  : 		
; 161  : 		newLength += injectionLen;
; 162  : 		
; 163  : 		// Copy the remainder of the method body.
; 164  : 		memcpy(&codeBuf[newLength], &header[FAT_HEADER_SIZE], length - FAT_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	mov	edx, DWORD PTR _header$[esp+144]
	add	esp, 12					; 0000000cH
	add	ecx, -12				; fffffff4H
	push	ecx
	add	edx, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR [esi+ebp+12]
	push	eax
	call	_memcpy

; 165  : 		newLength += (length - FAT_HEADER_SIZE);

	mov	ecx, DWORD PTR _length$[esp+140]
	lea	ebx, DWORD PTR [esi+ecx]

; 166  : 		
; 167  : 		// Reset the size of the code in the header itself.
; 168  : 		target->CodeSize = newLength - FAT_HEADER_SIZE;

	lea	ecx, DWORD PTR [ebx-12]
	mov	DWORD PTR [ebp+4], ecx

; 169  : 		
; 170  : 		// Increase MaxStack to allow our injection code to run.
; 171  : 		target->MaxStack = (method->MaxStack > 8) ? method->MaxStack : 8;

	movzx	eax, WORD PTR [edi+2]
	add	esp, 12					; 0000000cH
	cmp	ax, 8
	movzx	eax, ax
	ja	SHORT $LN21@Rewrite
	mov	eax, 8
$LN21@Rewrite:

; 172  : 		
; 173  : 		// Fix SEH sections
; 174  : 		FixSEHSections(target->GetSect(), injectionLen); 

	test	BYTE PTR [ebp], 8
	mov	WORD PTR [ebp+2], ax
	jne	SHORT $LN65@Rewrite
	xor	eax, eax
	push	esi
	call	?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z ; CProfiler::FixSEHSections
	jmp	SHORT $LN3@Rewrite
$LN65@Rewrite:
	movzx	edx, BYTE PTR [ebp+1]
	shr	edx, 4
	lea	eax, DWORD PTR [ecx+edx*4]
	lea	eax, DWORD PTR [eax+ebp+3]
	and	eax, -4					; fffffffcH
	push	esi
	call	?FixSEHSections@CProfiler@@AAEXPBUCOR_ILMETHOD_SECT@@H@Z ; CProfiler::FixSEHSections
	jmp	SHORT $LN3@Rewrite
$LN76@Rewrite:
	mov	ebx, DWORD PTR _newLength$[esp+132]
$LN3@Rewrite:

; 175  :     } else {
; 176  :     	DebugWriteLine(L"neither fat nor tiny ... invalid header???");
; 177  :     }
; 178  :     
; 179  :     if (codeBuf != nullptr && newLength > 0) {

	test	ebx, ebx
	jle	SHORT $LN9@Rewrite

; 180  :         hr = pICorProfilerInfo2->SetILFunctionBody(moduleID, token, codeBuf);

	mov	ecx, DWORD PTR _this$[esp+128]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _token$[esp+132]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+96]
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR _moduleID$[esp+140]
	push	ecx
	push	eax
	call	edx
$LN9@Rewrite:

; 181  :     }
; 182  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 116				; 00000074H
	ret	16					; 00000010H
?Rewrite@CProfiler@@AAEXIHH@Z ENDP			; CProfiler::Rewrite
; Function compile flags: /Ogtpy
;	COMDAT ?JITCompilationStarted@CProfiler@@UAGJIH@Z
_TEXT	SEGMENT
_name$ = -8						; size = 4
_nameId$ = -4						; size = 4
_this$ = 8						; size = 4
_functionID$ = 12					; size = 4
___formal$ = 16						; size = 4
?JITCompilationStarted@CProfiler@@UAGJIH@Z PROC		; CProfiler::JITCompilationStarted, COMDAT

; 429  : STDMETHODIMP CProfiler::JITCompilationStarted(FunctionID functionID, BOOL /*fIsSafeToBlock*/) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx

; 430  : 	WCHAR *name;
; 431  : 	int nameId = (int)MapFunction(functionID, (const WCHAR **)(&name));

	mov	ebx, DWORD PTR _functionID$[ebp]
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	lea	eax, DWORD PTR _name$[esp+24]
	push	eax
	push	ebx
	call	?MapFunction@CProfiler@@QAEIIPAPB_W@Z	; CProfiler::MapFunction

; 432  : 	
; 433  : 	if (name == nullptr)

	cmp	DWORD PTR _name$[esp+24], 0
	mov	DWORD PTR _nameId$[esp+24], eax

; 434  : 		return S_OK;

	je	$LN3@JITCompila

; 435  : 	
; 436  : 	for (int i = 0; i < CONSOLE_GROUP_LENGTH; i++) {

	mov	edi, OFFSET ?consoleGroupList@@3PAPA_WA	; consoleGroupList
$LN12@JITCompila:

; 437  : 		if (wcsstr(consoleGroupList[i], name) != nullptr) {

	mov	ecx, DWORD PTR _name$[esp+24]
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	eax
	call	DWORD PTR __imp__wcsstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@JITCompila

; 438  : 			DebugWriteLine(L"Rewriting %s", name);
; 439  : 			Rewrite(functionID, 0x1, nameId);

	mov	edx, DWORD PTR _nameId$[esp+24]
	push	edx
	push	1
	push	ebx
	push	esi
	call	?Rewrite@CProfiler@@AAEXIHH@Z		; CProfiler::Rewrite
$LN11@JITCompila:
	add	edi, 4
	cmp	edi, OFFSET ?consoleGroupList@@3PAPA_WA+8
	jl	SHORT $LN12@JITCompila

; 440  : 		}
; 441  : 	}
; 442  : 	
; 443  : 	for (int i = 0; i < WINFORMS_GROUP_LENGTH; i++) {

	mov	edi, OFFSET ?winFormsGroupList@@3PAPA_WA ; winFormsGroupList
$LL8@JITCompila:

; 444  : 		if (wcsstr(winFormsGroupList[i], name) != nullptr) {

	mov	ecx, DWORD PTR _name$[esp+24]
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	eax
	call	DWORD PTR __imp__wcsstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@JITCompila

; 445  : 			DebugWriteLine(L"Rewriting %s", name);
; 446  : 			Rewrite(functionID, 0x2, nameId);

	mov	edx, DWORD PTR _nameId$[esp+24]
	push	edx
	push	2
	push	ebx
	push	esi
	call	?Rewrite@CProfiler@@AAEXIHH@Z		; CProfiler::Rewrite
$LN7@JITCompila:
	add	edi, 4
	cmp	edi, OFFSET ?winFormsGroupList@@3PAPA_WA+16
	jl	SHORT $LL8@JITCompila

; 447  : 		}
; 448  : 	}
; 449  : 	
; 450  : 	for (int i = 0; i < WPF_GROUP_LENGTH; i++) {
; 451  : 		if (wcsstr(wpfGroupList[i], name) != nullptr) {

	mov	eax, DWORD PTR _name$[esp+24]
	mov	ecx, DWORD PTR ?wpfGroupList@@3PAPA_WA	; wpfGroupList
	push	eax
	push	ecx
	call	DWORD PTR __imp__wcsstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@JITCompila

; 452  : 			DebugWriteLine(L"Rewriting %s", name);
; 453  : 			Rewrite(functionID, 0x3, nameId);

	mov	edx, DWORD PTR _nameId$[esp+24]
	push	edx
	push	3
	push	ebx
	push	esi
	call	?Rewrite@CProfiler@@AAEXIHH@Z		; CProfiler::Rewrite
$LN3@JITCompila:

; 454  : 		}
; 455  : 	}
; 456  : 
; 457  : 	return S_OK;
; 458  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?JITCompilationStarted@CProfiler@@UAGJIH@Z ENDP		; CProfiler::JITCompilationStarted
END
