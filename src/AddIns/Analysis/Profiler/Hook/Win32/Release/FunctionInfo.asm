; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\FunctionInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_g_tkCorEncodeToken DD 02000000H
	DD	01000000H
	DD	01b000000H
	DD	072000000H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?AddOrUpdateChild@FunctionInfo@@QAEXPAU1@@Z	; FunctionInfo::AddOrUpdateChild
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\functioninfo.cpp
;	COMDAT ?AddOrUpdateChild@FunctionInfo@@QAEXPAU1@@Z
_TEXT	SEGMENT
_child$ = 8						; size = 4
?AddOrUpdateChild@FunctionInfo@@QAEXPAU1@@Z PROC	; FunctionInfo::AddOrUpdateChild, COMDAT
; _this$ = edx

; 40   : {

	push	ebx
	mov	ebx, DWORD PTR _child$[esp]
	push	esi

; 41   : 	int slot = child->Id;
; 42   : 	for (;;) {
; 43   : 		slot &= this->LastChildIndex;

	mov	esi, DWORD PTR [edx+20]
	push	edi
	mov	edi, DWORD PTR [ebx]
	mov	eax, edi
	and	eax, esi

; 44   : 		FunctionInfo *slotContent = this->Children[slot];

	mov	ecx, DWORD PTR [edx+eax*4+24]

; 45   : 		if (slotContent == nullptr || slotContent->Id == child->Id) {

	test	ecx, ecx
	je	SHORT $LN11@AddOrUpdat
$LL4@AddOrUpdat:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN11@AddOrUpdat

; 47   : 			break;
; 48   : 		}
; 49   : 		slot++;

	inc	eax
	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4+24]
	test	ecx, ecx
	jne	SHORT $LL4@AddOrUpdat
$LN11@AddOrUpdat:
	pop	edi
	pop	esi

; 46   : 			this->Children[slot] = child;

	mov	DWORD PTR [edx+eax*4+24], ebx
	pop	ebx

; 50   : 	}
; 51   : }

	ret	4
?AddOrUpdateChild@FunctionInfo@@QAEXPAU1@@Z ENDP	; FunctionInfo::AddOrUpdateChild
_TEXT	ENDS
PUBLIC	?Check@FunctionInfo@@QAEXXZ			; FunctionInfo::Check
; Function compile flags: /Ogtpy
;	COMDAT ?Check@FunctionInfo@@QAEXXZ
_TEXT	SEGMENT
?Check@FunctionInfo@@QAEXXZ PROC			; FunctionInfo::Check, COMDAT

; 28   : 	#ifdef DEBUG
; 29   : 	int fc = 0;
; 30   : 	for (int i = 0; i <= LastChildIndex; i++) {
; 31   : 		if (Children[i] != nullptr) {
; 32   : 			fc++;
; 33   : 		}
; 34   : 	}
; 35   : 	assert(fc == FillCount);
; 36   : 	#endif
; 37   : }

	ret	0
?Check@FunctionInfo@@QAEXXZ ENDP			; FunctionInfo::Check
PUBLIC	?FreeFunctionInfo@@YAXPAUFunctionInfo@@@Z	; FreeFunctionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?FreeFunctionInfo@@YAXPAUFunctionInfo@@@Z
_TEXT	SEGMENT
?FreeFunctionInfo@@YAXPAUFunctionInfo@@@Z PROC		; FreeFunctionInfo, COMDAT
; _f$ = esi

; 121  : 	sharedMemoryHeader->mallocator.free(f, sizeof(FunctionInfo) + (f->LastChildIndex + 1) * sizeof(FunctionInfo*));

	mov	eax, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [eax*4+28]
	mov	ecx, 374152163				; 164d1be3H
	mul	ecx
	mov	eax, DWORD PTR ?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A ; sharedMemoryHeader
	and	edx, 31					; 0000001fH
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4+64]
	push	edi
	npad	1
$LL5@FreeFuncti:
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ecx
	mov	edi, esi
	mov	ebx, edx
	mov	eax, ecx
	lock	 cmpxchg DWORD PTR [ebx], edi
	cmp	eax, ecx
	jne	SHORT $LL5@FreeFuncti
	pop	edi
	pop	ebx

; 122  : }

	ret	0
?FreeFunctionInfo@@YAXPAUFunctionInfo@@@Z ENDP		; FreeFunctionInfo
_TEXT	ENDS
PUBLIC	?Resize@FunctionInfo@@AAEPAU1@H@Z		; FunctionInfo::Resize
; Function compile flags: /Ogtpy
;	COMDAT ?Resize@FunctionInfo@@AAEPAU1@H@Z
_TEXT	SEGMENT
_newTableSize$ = 8					; size = 4
?Resize@FunctionInfo@@AAEPAU1@H@Z PROC			; FunctionInfo::Resize, COMDAT
; _this$ = eax

; 69   : {

	push	ebx
	mov	ebx, DWORD PTR _newTableSize$[esp]
	push	esi
	mov	esi, eax

; 70   : //	DebugWriteLine("Resize %d", Id);
; 71   : 	// Allocate space for the copy
; 72   : 	FunctionInfo* newFunction = (FunctionInfo *)sharedMemoryHeader->mallocator.malloc(sizeof(FunctionInfo) + newTableSize * sizeof(void*));

	mov	eax, DWORD PTR ?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A ; sharedMemoryHeader
	push	edi
	add	eax, 52					; 00000034H
	lea	edi, DWORD PTR [ebx*4+24]
	push	eax
	call	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc

; 73   : 
; 74   : 	// Copy the header
; 75   : 	memcpy(newFunction, this, sizeof(FunctionInfo));

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx

; 76   : 	// Initialize the new table
; 77   : 	newFunction->LastChildIndex = newTableSize - 1;

	dec	ebx
	mov	DWORD PTR [eax+20], ebx

; 78   : 	// Copy the old table entries
; 79   : 	int oldTableSize = this->LastChildIndex + 1;

	mov	ecx, DWORD PTR [esi+20]
	inc	ecx

; 80   : 	for(int i = 0; i < oldTableSize; i++) {

	test	ecx, ecx
	jle	SHORT $LN2@Resize
	push	ebp
	lea	ebx, DWORD PTR [esi+24]
	mov	ebp, ecx
	npad	4
$LL19@Resize:

; 81   : 		FunctionInfo *child = this->Children[i];

	mov	edi, DWORD PTR [ebx]

; 82   : 		if (child != nullptr) {

	test	edi, edi
	je	SHORT $LN3@Resize

; 83   : 			newFunction->AddOrUpdateChild(child);

	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, esi
	mov	edx, DWORD PTR [eax+ecx*4+24]
	test	edx, edx
	je	SHORT $LN15@Resize
$LL10@Resize:
	cmp	DWORD PTR [edx], esi
	je	SHORT $LN15@Resize
	inc	ecx
	and	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+ecx*4+24]
	test	edx, edx
	jne	SHORT $LL10@Resize
$LN15@Resize:
	mov	DWORD PTR [eax+ecx*4+24], edi
$LN3@Resize:

; 80   : 	for(int i = 0; i < oldTableSize; i++) {

	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL19@Resize
	pop	ebp
$LN2@Resize:
	pop	edi
	pop	esi
	pop	ebx

; 84   : 		}
; 85   : 	}
; 86   : 	// we cannot delete the original yet - we need to wait until all pointers to it have been updated,
; 87   : 	// because updating a pointer is safely possible only while the original still exists!
; 88   : 	// Done - FunctionInfo was resized
; 89   : 	return newFunction;
; 90   : }

	ret	4
?Resize@FunctionInfo@@AAEPAU1@H@Z ENDP			; FunctionInfo::Resize
_TEXT	ENDS
PUBLIC	?CreateFunctionInfo@@YAPAUFunctionInfo@@HH@Z	; CreateFunctionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?CreateFunctionInfo@@YAPAUFunctionInfo@@HH@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
_indexInParent$ = 12					; size = 4
?CreateFunctionInfo@@YAPAUFunctionInfo@@HH@Z PROC	; CreateFunctionInfo, COMDAT

; 55   : 	// Allocate the child in memory
; 56   : 	FunctionInfo* newFunction = (FunctionInfo *)sharedMemoryHeader->mallocator.malloc(sizeof(FunctionInfo) + defaultTableSize * sizeof(void*));

	mov	eax, DWORD PTR ?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A ; sharedMemoryHeader
	push	edi
	add	eax, 52					; 00000034H
	push	eax
	mov	edi, 40					; 00000028H
	call	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc

; 57   : 	// the allocater takes care of zeroing the memory
; 58   : 	
; 59   : 	// Set field values
; 60   : 	newFunction->Id = id;

	mov	edx, DWORD PTR _id$[esp]
	mov	ecx, eax

; 61   : 	newFunction->TimeSpent = (ULONGLONG)indexInParent << 56;

	mov	eax, DWORD PTR _indexInParent$[esp]
	mov	DWORD PTR [ecx], edx
	cdq
	shl	eax, 24					; 00000018H
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+8], 0

; 62   : 	// Initialize the table
; 63   : 	newFunction->LastChildIndex = defaultTableSize - 1;

	mov	DWORD PTR [ecx+20], 3

; 64   : 	// Return pointer to the created child
; 65   : 	return newFunction;

	mov	eax, ecx
	pop	edi

; 66   : }

	ret	0
?CreateFunctionInfo@@YAPAUFunctionInfo@@HH@Z ENDP	; CreateFunctionInfo
PUBLIC	?GetOrAddChild@FunctionInfo@@QAEPAU1@HAAPAU1@@Z	; FunctionInfo::GetOrAddChild
; Function compile flags: /Ogtpy
;	COMDAT ?GetOrAddChild@FunctionInfo@@QAEPAU1@HAAPAU1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
tv181 = 12						; size = 4
_functionID$ = 12					; size = 4
_newParent$ = 16					; size = 4
?GetOrAddChild@FunctionInfo@@QAEPAU1@HAAPAU1@@Z PROC	; FunctionInfo::GetOrAddChild, COMDAT

; 93   : {

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 94   : 	int lastChildIndex = this->LastChildIndex;

	mov	ecx, DWORD PTR [ebx+20]
	push	ebp
	mov	ebp, DWORD PTR _functionID$[esp+4]
	push	esi

; 95   : 	int slot = functionID;
; 96   : 	for (;;) {
; 97   : 		slot &= lastChildIndex;

	mov	esi, ecx
	and	esi, ebp

; 98   : 		FunctionInfo *slotContent = this->Children[slot];

	mov	eax, DWORD PTR [ebx+esi*4+24]

; 99   : 		if (slotContent == nullptr) {

	test	eax, eax
	je	SHORT $LN18@GetOrAddCh
	npad	6
$LL7@GetOrAddCh:

; 112  : 		} else if (slotContent->Id == functionID) {

	cmp	DWORD PTR [eax], ebp
	je	$LN6@GetOrAddCh

; 113  : 			return slotContent;
; 114  : 		}
; 115  : 		slot++;

	inc	esi
	and	esi, ecx
	mov	eax, DWORD PTR [ebx+esi*4+24]
	test	eax, eax
	jne	SHORT $LL7@GetOrAddCh
$LN18@GetOrAddCh:

; 100  : 			this->FillCount++;

	inc	DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR tv181[esp+8], eax

; 101  : 			if (this->FillCount * 4 >= lastChildIndex * 3) {

	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [ecx+ecx*2]
	cmp	eax, edx
	push	edi
	jl	SHORT $LN4@GetOrAddCh

; 102  : 				// resize table
; 103  : 				newParent = this->Resize(2 * (lastChildIndex + 1));

	lea	eax, DWORD PTR [ecx+ecx+2]
	push	eax
	mov	eax, ebx
	call	?Resize@FunctionInfo@@AAEPAU1@H@Z	; FunctionInfo::Resize

; 104  : 				slotContent = CreateFunctionInfo(functionID, newParent->FillCount);

	mov	ecx, DWORD PTR ?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A ; sharedMemoryHeader
	mov	ebx, DWORD PTR _newParent$[esp+12]
	mov	esi, DWORD PTR [eax+16]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edi, 40					; 00000028H
	mov	DWORD PTR [ebx], eax
	call	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc
	mov	ecx, eax
	mov	eax, esi
	cdq

; 105  : 				newParent->AddOrUpdateChild(slotContent);

	mov	edx, DWORD PTR [ebx]
	shl	eax, 24					; 00000018H
	push	ecx
	mov	DWORD PTR [ecx], ebp
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+20], 3
	mov	edi, ecx
	call	?AddOrUpdateChild@FunctionInfo@@QAEXPAU1@@Z ; FunctionInfo::AddOrUpdateChild

; 109  : 				this->Children[slot] = slotContent;
; 110  : 			}
; 111  : 			return slotContent;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 116  : 	}
; 117  : }

	ret	12					; 0000000cH
$LN4@GetOrAddCh:

; 106  : 				newParent->Check();
; 107  : 			} else {
; 108  : 				slotContent = CreateFunctionInfo(functionID, this->FillCount);

	mov	edx, DWORD PTR ?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A ; sharedMemoryHeader
	add	edx, 52					; 00000034H
	push	edx
	mov	edi, 40					; 00000028H
	call	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc
	mov	ecx, eax
	mov	eax, DWORD PTR tv181[esp+12]
	cdq
	shl	eax, 24					; 00000018H
	mov	edi, ecx
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx], ebp
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+20], 3

; 109  : 				this->Children[slot] = slotContent;
; 110  : 			}
; 111  : 			return slotContent;

	mov	eax, edi
	mov	DWORD PTR [ebx+esi*4+24], ecx
	pop	edi
$LN6@GetOrAddCh:
	pop	esi
	pop	ebp
	pop	ebx

; 116  : 	}
; 117  : }

	ret	12					; 0000000cH
?GetOrAddChild@FunctionInfo@@QAEPAU1@HAAPAU1@@Z ENDP	; FunctionInfo::GetOrAddChild
END
