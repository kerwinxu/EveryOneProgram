; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\allocator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_InterlockedCompareExchangePointer@@YAPAXPCRAXPAX1@Z ; _InterlockedCompareExchangePointer
PUBLIC	?allocMappingFunc@FunctionInfoAllocationSize@@SAII@Z ; FunctionInfoAllocationSize::allocMappingFunc
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QBIB ; FunctionInfoAllocationSize::PossibleAllocationSizes
PUBLIC	??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@	; `string'
PUBLIC	??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@ ; `string'
PUBLIC	??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@		; `string'
PUBLIC	??_R0?AUFunctionInfoAllocationSize@@@8		; FunctionInfoAllocationSize `RTTI Type Descriptor'
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:QWORD ; __type_info_root_node
EXTRN	__imp_?name@type_info@@QBEPBDPAU__type_info_node@@@Z:PROC
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT ??_R0?AUFunctionInfoAllocationSize@@@8
_DATA	SEGMENT
??_R0?AUFunctionInfoAllocationSize@@@8 DD FLAT:??_7type_info@@6B@ ; FunctionInfoAllocationSize `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUFunctionInfoAllocationSize@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@
CONST	SEGMENT
??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@ DB 'fatal error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@
CONST	SEGMENT
??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@ DB '> Self Test Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@
CONST	SEGMENT
??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@ DB 'freeListAllocator<', 00H ; `string'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QBIB DD 020H ; FunctionInfoAllocationSize::PossibleAllocationSizes
	DD	028H
	DD	038H
	DD	058H
	DD	098H
	DD	0118H
	DD	0218H
	DD	0418H
	DD	0818H
	DD	01018H
	DD	02018H
	DD	04018H
	DD	08018H
	DD	010018H
	DD	020018H
	DD	040018H
	DD	080018H
	DD	0100018H
	DD	0200018H
	DD	0400018H
	DD	0800018H
	DD	01000018H
	DD	02000018H
	DD	04000018H
	DD	08000018H
	DD	010000018H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?free@fastAllocator@@QAEXPAXI@Z			; fastAllocator::free
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\allocator.cpp
;	COMDAT ?free@fastAllocator@@QAEXPAXI@Z
_TEXT	SEGMENT
?free@fastAllocator@@QAEXPAXI@Z PROC			; fastAllocator::free, COMDAT

; 81   : 	assert(memory != nullptr);
; 82   : 	assert(memory >= startPos && memory < endPos);
; 83   : 	#if DEBUG
; 84   : 	assert(((size_t*)memory)[-1] == bytes);
; 85   : 	#endif
; 86   : }

	ret	0
?free@fastAllocator@@QAEXPAXI@Z ENDP			; fastAllocator::free
_TEXT	ENDS
PUBLIC	?malloc@fastAllocator@@QAEPAXI@Z		; fastAllocator::malloc
; Function compile flags: /Ogtpy
;	COMDAT ?malloc@fastAllocator@@QAEPAXI@Z
_TEXT	SEGMENT
?malloc@fastAllocator@@QAEPAXI@Z PROC			; fastAllocator::malloc, COMDAT
; _this$ = edx
; _bytes$ = ecx

; 49   : {

	push	ebx
	push	esi

; 50   : 	assert(pos != nullptr); // ensure allocator is initialized before malloc is called
; 51   : 	
; 52   : 	// must be compatible with C# malloc! (used in Data Collection)
; 53   : 	
; 54   : 	#if DEBUG
; 55   : 	// space for debugging info
; 56   : 	const size_t debuggingInfoSize = 8; //sizeof(size_t); - always use 8 so we keep proper alignment for LONGLONGs
; 57   : 	bytes += debuggingInfoSize; 
; 58   : 	#endif
; 59   : 	
; 60   : 	#ifdef _M_AMD64
; 61   : 	void *t = (void*)_InterlockedExchangeAdd64((__int64 volatile*)&pos, (__int64)bytes);
; 62   : 	#else
; 63   : 	void *t = (void*)_InterlockedExchangeAdd((LONG volatile*)&pos, (LONG)bytes);

	mov	eax, ecx
	lea	esi, DWORD PTR [edx+4]
	lock	 xadd	 DWORD PTR [esi], eax

; 64   : 	#endif
; 65   : 	
; 66   : 	if ((byte*)endPos - (byte*)t > (ptrdiff_t)bytes) {

	mov	edx, DWORD PTR [edx+8]
	sub	edx, eax
	xor	ebx, ebx
	cmp	edx, ecx
	setle	bl
	pop	esi
	dec	ebx
	and	eax, ebx
	pop	ebx

; 67   : 		#if DEBUG
; 68   : 		t = (byte*)t + debuggingInfoSize; // skip over debugging info
; 69   : 		((size_t*)t)[-1] = bytes - debuggingInfoSize;
; 70   : 		#endif
; 71   : 		assert(isAligned(t));
; 72   : 		return t;
; 73   : 	} else {
; 74   : 		return nullptr;
; 75   : 	}
; 76   : }

	ret	0
?malloc@fastAllocator@@QAEPAXI@Z ENDP			; fastAllocator::malloc
_TEXT	ENDS
PUBLIC	?initialize@fastAllocator@@QAEXPAX0@Z		; fastAllocator::initialize
; Function compile flags: /Ogtpy
;	COMDAT ?initialize@fastAllocator@@QAEXPAX0@Z
_TEXT	SEGMENT
_endPos$ = 8						; size = 4
?initialize@fastAllocator@@QAEXPAX0@Z PROC		; fastAllocator::initialize, COMDAT
; _this$ = eax
; _pos$ = ecx

; 37   : 	assert(isAligned(pos));
; 38   : 	assert(pos != nullptr);
; 39   : 	assert(endPos > pos);
; 40   : 	
; 41   : 	assert(startPos == nullptr);
; 42   : 	
; 43   : 	this->startPos = pos;

	mov	DWORD PTR [eax], ecx

; 44   : 	this->pos = pos;

	mov	DWORD PTR [eax+4], ecx

; 45   : 	this->endPos = endPos;

	mov	ecx, DWORD PTR _endPos$[esp-4]
	mov	DWORD PTR [eax+8], ecx

; 46   : }

	ret	4
?initialize@fastAllocator@@QAEXPAX0@Z ENDP		; fastAllocator::initialize
_TEXT	ENDS
PUBLIC	??0fastAllocator@@QAE@XZ			; fastAllocator::fastAllocator
; Function compile flags: /Ogtpy
;	COMDAT ??0fastAllocator@@QAE@XZ
_TEXT	SEGMENT
??0fastAllocator@@QAE@XZ PROC				; fastAllocator::fastAllocator, COMDAT
; _this$ = eax

; 32   : {

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 33   : }

	ret	0
??0fastAllocator@@QAE@XZ ENDP				; fastAllocator::fastAllocator
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\allocator.h
_TEXT	ENDS
;	COMDAT ?allocMappingFunc@FunctionInfoAllocationSize@@SAII@Z
_TEXT	SEGMENT
?allocMappingFunc@FunctionInfoAllocationSize@@SAII@Z PROC ; FunctionInfoAllocationSize::allocMappingFunc, COMDAT
; _bytes$ = eax

; 60   : 		return (UINT_PTR)(((bytes * 374152163ULL) >> 32) & 31);

	mov	ecx, 374152163				; 164d1be3H
	mul	ecx
	mov	eax, edx
	and	eax, 31					; 0000001fH

; 61   : 	}

	ret	0
?allocMappingFunc@FunctionInfoAllocationSize@@SAII@Z ENDP ; FunctionInfoAllocationSize::allocMappingFunc
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\main.h
_TEXT	ENDS
;	COMDAT ?_InterlockedCompareExchangePointer@@YAPAXPCRAXPAX1@Z
_TEXT	SEGMENT
_Comparand$ = 8						; size = 4
?_InterlockedCompareExchangePointer@@YAPAXPCRAXPAX1@Z PROC ; _InterlockedCompareExchangePointer, COMDAT
; _Destination$ = edx
; _ExChange$ = ecx

; 70   : 	return ((PVOID)(LONG_PTR)_InterlockedCompareExchange((LONG volatile *)Destination, (LONG)(LONG_PTR)ExChange, (LONG)(LONG_PTR)Comparand));

	mov	eax, DWORD PTR _Comparand$[esp-4]
	lock	 cmpxchg DWORD PTR [edx], ecx

; 71   : }

	ret	0
?_InterlockedCompareExchangePointer@@YAPAXPCRAXPAX1@Z ENDP ; _InterlockedCompareExchangePointer
PUBLIC	?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::free
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\allocator.cpp
;	COMDAT ?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAXI@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::free, COMDAT
; _memory$ = esi
; _bytes$ = eax

; 148  : 	// the base allocator cannot free, just allow it to check whether 'bytes' is the correct size
; 149  : 	allocator.free(memory, bytes);
; 150  : 	
; 151  : 	assert(bytes >= sizeof(void*));
; 152  : 	assert(isPossibleAllocationSize(bytes));
; 153  : 	
; 154  : //	DebugWriteLine("Freeing memory of size %Id", bytes);
; 155  : 	void* volatile* freeListSlot = &freeList[T::allocMappingFunc(bytes)];

	mov	ecx, 374152163				; 164d1be3H
	mul	ecx
	mov	eax, DWORD PTR _this$[esp-4]
	and	edx, 31					; 0000001fH
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4+12]
	push	edi
$LL3@free:

; 156  : 	void* t;
; 157  : 	do {
; 158  : 		t = *freeListSlot;

	mov	ecx, DWORD PTR [edx]

; 159  : 		*(void**)memory = t;

	mov	DWORD PTR [esi], ecx

; 160  : 	} while (InterlockedCompareExchangePointer(freeListSlot, memory, t) != t);

	mov	edi, esi
	mov	ebx, edx
	mov	eax, ecx
	lock	 cmpxchg DWORD PTR [ebx], edi
	cmp	eax, ecx
	jne	SHORT $LL3@free
	pop	edi
	pop	ebx

; 161  : }

	ret	4
?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAXI@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::free
_TEXT	ENDS
PUBLIC	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::malloc, COMDAT
; _bytes$ = edi

; 131  : 	assert(bytes >= sizeof(void*));
; 132  : 	assert(isPossibleAllocationSize(bytes));
; 133  : 	void* volatile* freeListSlot = &freeList[T::allocMappingFunc(bytes)];

	mov	ecx, 374152163				; 164d1be3H
	mov	eax, edi
	mul	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	push	ebp
	and	edx, 31					; 0000001fH
	push	esi
	lea	ecx, DWORD PTR [ebx+edx*4+12]
$LL4@malloc:

; 134  : 	void* t;
; 135  : 	void* next;
; 136  : 	do {
; 137  : 		t = *freeListSlot; // volatile read has acquire semantics

	mov	esi, DWORD PTR [ecx]

; 138  : 		if (t == nullptr)

	test	esi, esi
	je	SHORT $LN16@malloc

; 140  : //		DebugWriteLine("Reusing memory of size %Id", bytes);
; 141  : 		next = *(void**)t;
; 142  : 	} while (InterlockedCompareExchangePointer(freeListSlot, next, t) != t);

	mov	edx, DWORD PTR [esi]
	mov	ebp, ecx
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ebp], edx
	cmp	eax, esi
	jne	SHORT $LL4@malloc

; 143  : 	memset(t, 0, bytes);

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 144  : 	return t;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 145  : }

	ret	4
$LN16@malloc:

; 139  : 			return allocator.malloc(bytes);

	mov	eax, edi
	lea	ecx, DWORD PTR [ebx+4]
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [ebx+8]
	sub	edx, eax
	xor	ecx, ecx
	cmp	edx, edi
	setle	cl
	pop	esi
	pop	ebp
	pop	ebx
	dec	ecx
	and	eax, ecx

; 145  : }

	ret	4
?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEPAXI@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::malloc
_TEXT	ENDS
PUBLIC	?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAX0@Z ; freeListAllocator<FunctionInfoAllocationSize>::initialize
; Function compile flags: /Ogtpy
;	COMDAT ?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAX0@Z
_TEXT	SEGMENT
_endPos$ = 8						; size = 4
?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAX0@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::initialize, COMDAT
; _this$ = eax
; _pos$ = ecx

; 91   : 	allocator.initialize(pos, endPos);

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _endPos$[esp-4]
	mov	DWORD PTR [eax+8], ecx

; 92   : }

	ret	4
?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAEXPAX0@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::initialize
_TEXT	ENDS
PUBLIC	??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ$0
__ehfuncinfo$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\allocator.cpp
xdata$x	ENDS
;	COMDAT ??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ
_TEXT	SEGMENT
_msg$89216 = -40					; size = 28
__$EHRec$ = -12						; size = 12
??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ PROC ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>, COMDAT

; 95   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	xor	esi, esi
	mov	DWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A, esi
	mov	DWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+4, esi
	mov	DWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+8, esi
	mov	eax, OFFSET ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+12
$LL10@freeListAl:

; 96   : 	for (int i = 0; i < freeListSize; i++) {
; 97   : 		freeList[i] = nullptr;

	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, OFFSET ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+140
	jl	SHORT $LL10@freeListAl

; 98   : 	}
; 99   : 	// check if the allocMappingFunc works for our allocation size
; 100  : 	const int numberOfAllocationSizes = sizeof(T::PossibleAllocationSizes) / sizeof(size_t);
; 101  : 	for (int i = 0; i < numberOfAllocationSizes; i++) {

	mov	ecx, OFFSET ?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QBIB ; FunctionInfoAllocationSize::PossibleAllocationSizes
$LL7@freeListAl:

; 102  : 		void* volatile & slot = freeList[T::allocMappingFunc( T::PossibleAllocationSizes[i] )];

	mov	eax, DWORD PTR [ecx]
	mov	edx, 374152163				; 164d1be3H
	mul	edx
	and	edx, 31					; 0000001fH
	lea	eax, DWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A[edx*4+12]

; 103  : 		if (slot != nullptr) {

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	jne	SHORT $LN27@freeListAl
	add	ecx, 4
	cmp	ecx, OFFSET ?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QBIB+104

; 109  : 		}
; 110  : 		slot = (void*)1;

	mov	DWORD PTR [eax], 1
	jl	SHORT $LL7@freeListAl

; 103  : 		if (slot != nullptr) {

	jmp	SHORT $LN5@freeListAl
$LN27@freeListAl:

; 104  : 			std::string msg = "freeListAllocator<";

	push	OFFSET ??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@
	lea	ecx, DWORD PTR _msg$89216[esp+48]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 105  : 			msg += typeid(T).name();

	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUFunctionInfoAllocationSize@@@8
	mov	DWORD PTR __$EHRec$[esp+56], esi
	call	DWORD PTR __imp_?name@type_info@@QBEPBDPAU__type_info_node@@@Z
	push	eax
	lea	ecx, DWORD PTR _msg$89216[esp+48]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 106  : 			msg += "> Self Test Failed";

	push	OFFSET ??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@
	lea	ecx, DWORD PTR _msg$89216[esp+48]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 107  : 			MessageBox(nullptr, msg.c_str(), TEXT("fatal error!"), MB_OK);

	cmp	DWORD PTR _msg$89216[esp+68], 16	; 00000010H
	mov	eax, DWORD PTR _msg$89216[esp+48]
	jae	SHORT $LN23@freeListAl
	lea	eax, DWORD PTR _msg$89216[esp+48]
$LN23@freeListAl:
	push	esi
	push	OFFSET ??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@
	push	eax
	push	esi
	call	DWORD PTR __imp__MessageBoxA@16

; 108  : 			break;

	lea	ecx, DWORD PTR _msg$89216[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@freeListAl:

; 111  : 	}
; 112  : 	
; 113  : 	for (int i = 0; i < freeListSize; i++) {

	mov	eax, OFFSET ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+12
$LL3@freeListAl:

; 114  : 		freeList[i] = nullptr;

	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, OFFSET ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+140
	jl	SHORT $LL3@freeListAl

; 115  : 	}
; 116  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, OFFSET ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A ; mallocator
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ$0:
	lea	ecx, DWORD PTR _msg$89216[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ ENDP ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>
END
