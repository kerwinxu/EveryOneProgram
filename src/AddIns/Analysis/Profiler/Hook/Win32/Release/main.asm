; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\Program\c#\SharpDevelop5\src\AddIns\Analysis\Profiler\Hook\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??0?$LightweightStack@UStackEntry@@@@QAE@XZ	; LightweightStack<StackEntry>::LightweightStack<StackEntry>
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1CriticalSection@@QAE@XZ			; CriticalSection::~CriticalSection
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >
PUBLIC	??1?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>::destroy
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::end
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Color
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBIPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::const_iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::iterator::iterator
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Make_iter
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Max
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Mynode
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::deallocate
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::destroy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lmost
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Root
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::clear
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Left
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Min
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator==
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator!=
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
PUBLIC	??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >
PUBLIC	??1?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>::destroy
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::end
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Color
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBKPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBKPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::const_iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::iterator::iterator
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Make_iter
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Max
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Mynode
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::deallocate
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::destroy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lmost
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Root
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::clear
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Left
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Min
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator==
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator!=
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
PUBLIC	??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >
PUBLIC	??1?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::~_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>::destroy
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::end
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Color
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIVHandlerInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBIVHandlerInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::const_iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::iterator
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Make_iter
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Max
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Mynode
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::deallocate
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::destroy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lmost
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Root
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::clear
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Left
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Min
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator==
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator!=
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
PUBLIC	??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >
PUBLIC	??1CProfiler@@QAE@XZ				; CProfiler::~CProfiler
PUBLIC	?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A	; sharedMemoryHeader
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_02JMMFPCED@?$CC?$CC?$AA@			; `string'
PUBLIC	??_C@_1CI@DFGEPGFH@?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?3?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:PROC
EXTRN	__imp_??0?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:PROC
EXTRN	__imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ:PROC
EXTRN	__imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:PROC
EXTRN	__imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ:PROC
EXTRN	__imp_??1locale@std@@QAE@XZ:PROC
EXTRN	__imp_?widen@?$ctype@_W@std@@QBE_WD@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp_??0bad_cast@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:PROC
EXTRN	?facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::facet_Register
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:PROC
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_??1bad_cast@std@@UAE@XZ:PROC
EXTRN	__imp_??0bad_cast@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:PROC
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:PROC
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:PROC
EXTRN	__imp_?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IBEPB_WXZ:PROC
EXTRN	__imp_?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	__imp___invalid_parameter_noinfo:PROC
?sharedMemoryHeader@@3PAUSharedMemoryHeader@@A DD 01H DUP (?) ; sharedMemoryHeader
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DFGEPGFH@?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?3?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DFGEPGFH@?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?3?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@ DB 'e'
	DB	00H, 'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, '"', 00H, '%'
	DB	00H, 's', 00H, ':', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFPCED@?$CC?$CC?$AA@
CONST	SEGMENT
??_C@_02JMMFPCED@?$CC?$CC?$AA@ DB '""', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_g_tkCorEncodeToken DD 02000000H
	DD	01000000H
	DD	01b000000H
	DD	072000000H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 18   : 	if (&_Left != &_Right)

	cmp	ecx, eax
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [ecx]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [eax], dl
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	add	eax, 29					; 0000001dH

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Isnil
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	add	eax, 28					; 0000001cH

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Isnil
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Isnil
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 83   : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, eax
	jmp	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN1@Sentry_bas:

; 84   : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Ostr$ = eax

; 75   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR [esi], eax

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas@2

; 77   : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, eax
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN8@Sentry_bas@2:

; 78   : 			}

	mov	eax, esi
	ret	0
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Right
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Parent
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);
; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Right
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Parent
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);
; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Right
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Parent
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);
; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);
; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = eax

; 116  : 			return (_Ok);

	mov	al, BYTE PTR [eax+4]

; 117  : 			}

	ret	0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT

; 102  : 			{	// destroy the object

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN1@sentry

; 106  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN1@sentry:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[esp+24], -1
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN5@sentry
	mov	ecx, eax
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN5@sentry:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; __Ostr$ = esi

; 95   : 			{	// construct locking and testing stream

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	edi
	mov	edi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi+40]
	test	ecx, ecx
	je	SHORT $LN5@sentry@2
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN5@sentry@2:
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN1@sentry@2
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN1@sentry@2

; 97   : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$LN1@sentry@2:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+esi+8], 0

; 99   : 			}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	sete	al
	mov	BYTE PTR [edi+4], al
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	_rdtsc@4
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\main.cpp
;	COMDAT _rdtsc@4
_TEXT	SEGMENT
_tsc$ = 8						; size = 4
_rdtsc@4 PROC						; COMDAT

; 54   :  *tsc = __rdtsc();

	mov	ecx, DWORD PTR _tsc$[esp-4]
	rdtsc
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 55   :  return S_OK;

	xor	eax, eax

; 56   : }

	ret	4
_rdtsc@4 ENDP
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\criticalsection.h
_TEXT	ENDS
;	COMDAT ??1CriticalSection@@QAE@XZ
_TEXT	SEGMENT
??1CriticalSection@@QAE@XZ PROC				; CriticalSection::~CriticalSection, COMDAT
; _this$ = eax

; 35   : 		DeleteCriticalSection(&criticalSection);

	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 36   : 	}

	ret	0
??1CriticalSection@@QAE@XZ ENDP				; CriticalSection::~CriticalSection
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[esp+32], 0
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xlocale
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = eax

; 135  : #if defined(_M_CEE)
; 136  : 			facet_Register_m(this);
; 137  : #else
; 138  : 			facet_Register(this);

	push	eax
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	pop	ecx

; 139  : #endif
; 140  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 36   : 		}

	ret	0

; 35   : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 36   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Message$ = 12						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT

; 26   : 		{	// construct from message string

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	ecx, esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 468  : 		return _Myaux != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 469  : 		}

	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = eax
; __Other$ = edx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 464  : 		}

	ret	0
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = edx
; __Pcont$ = eax

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 454  : 		}

	ret	0
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = eax

; 448  : 	_Iterator_base_aux()

	mov	DWORD PTR [eax], 0
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$3
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$4
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 2
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 873  : 	{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi

; 874  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 875  : 	ios_base::iostate _State = ios_base::goodbit;
; 876  : 	const typename _Myos::sentry _Ok(_Ostr);

	lea	eax, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	xor	edi, edi
	push	eax
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 877  : 
; 878  : 	if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN20@operator@2

; 879  : 		{	// state okay, insert
; 880  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi+24]
	cmp	eax, 1
	lea	ecx, DWORD PTR [edx+esi]
	jle	SHORT $LN16@operator@2
	lea	ebx, DWORD PTR [eax-1]
$LN16@operator@2:

; 881  : 
; 882  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 883  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [ecx+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN69@operator@2
$LL9@operator@2:

; 884  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 885  : 				--_Pad)	// pad on left

	test	edi, edi
	jne	$LN2@operator@2
	test	ebx, ebx
	jle	SHORT $LN69@operator@2

; 886  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 887  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [ecx+esi+48]
	lea	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	edx, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LN8@operator@2

; 888  : 					_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
$LN8@operator@2:

; 884  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 885  : 				--_Pad)	// pad on left

	dec	ebx
	jmp	SHORT $LL9@operator@2
$LN69@operator@2:

; 889  : 
; 890  : 		if (_State == ios_base::goodbit
; 891  : 			&& _Traits::eq_int_type(_Traits::eof(),
; 892  : 				_Ostr.rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [ecx+esi+40]
	push	edx
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LL70@operator@2

; 893  : 			_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
	npad	5
$LL70@operator@2:

; 894  : 
; 895  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 896  : 			--_Pad)	// pad on right

	test	edi, edi
	jne	SHORT $LN2@operator@2
	test	ebx, ebx
	jle	SHORT $LN2@operator@2

; 897  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 898  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN3@operator@2

; 899  : 				_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
$LN3@operator@2:

; 894  : 
; 895  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 896  : 			--_Pad)	// pad on right

	dec	ebx
	jmp	SHORT $LL70@operator@2
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$0:

; 900  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN21@operator@2
	ret	0
$LN21@operator@2:
	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	jmp	SHORT $LN20@operator@2
$LN2@operator@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN20@operator@2:

; 901  : 		}
; 902  : 
; 903  : 	_Ostr.width(0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	mov	DWORD PTR [eax+24], 0

; 904  : 	_Ostr.setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	push	0
	push	edi
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 905  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 3
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN54@operator@2
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN54@operator@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax+40]
	test	ecx, ecx
	je	SHORT $LN72@operator@2
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN72@operator@2:

; 906  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$3:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$103652 = -32					; size = 4
__Lock$103651 = -28					; size = 4
$T125710 = -24						; size = 12
__$EHRec$ = -12						; size = 12
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT
; __Loc$ = ecx

; 486  : {	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	edi, ecx

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$103651[esp+44]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	mov	DWORD PTR __$EHRec$[esp+48], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 490  : 
; 491  : 		size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
	mov	DWORD PTR __Psave$103652[esp+40], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
	mov	esi, eax

; 493  : 
; 494  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN14@use_facet

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

	mov	esi, DWORD PTR __Psave$103652[esp+40]
	test	esi, esi

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

	jne	SHORT $LN14@use_facet

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	ecx, DWORD PTR __Psave$103652[esp+40]
	push	edi
	push	ecx
	call	DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T125710[esp+44]
	call	DWORD PTR __imp_??0bad_cast@std@@QAE@PBD@Z
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T125710[esp+44]
	push	edx
	call	__CxxThrowException@8
$LN18@use_facet:
$LN2@use_facet:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

	mov	ecx, DWORD PTR __Psave$103652[esp+40]
	mov	esi, ecx

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	edi, ecx

; 513  : 			_Pfmod->_Incref();

	call	DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 514  : 			_Pfmod->_Register();

	push	edi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN14@use_facet:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$103651[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 518  : 	_END_LOCK()
; 519  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
$LN17@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$103651[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIVHandlerInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIVHandlerInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIVHandlerInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBKPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBKPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBKPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVThreadInfo@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIVHandlerInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBIVHandlerInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBIVHandlerInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>::_Bidit<std::pair<unsigned int const ,HandlerInfo>,int,std::pair<unsigned int const ,HandlerInfo> const *,std::pair<unsigned int const ,HandlerInfo> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBKPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBKPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBKPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned long const ,ThreadInfo *>,int,std::pair<unsigned long const ,ThreadInfo *> const *,std::pair<unsigned long const ,ThreadInfo *> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBIPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBIPAVThreadInfo@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>::_Bidit<std::pair<unsigned int const ,ThreadInfo *>,int,std::pair<unsigned int const ,ThreadInfo *> const *,std::pair<unsigned int const ,ThreadInfo *> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 234  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN3@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 237  : 			}

	mov	eax, esi
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 234  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN3@const_iter@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@const_iter@2:

; 236  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 237  : 			}

	mov	eax, esi
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 234  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN3@const_iter@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@const_iter@3:

; 236  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 237  : 			}

	mov	eax, esi
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 234  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN3@const_iter@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@const_iter@4:

; 236  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 237  : 			}

	mov	eax, esi
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Root, COMDAT
; _this$ = eax

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN1@Min
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Min
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN1@Max
	npad	7
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Max
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR [ecx+8]

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+29], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+29], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min@2
$LL2@Min@2:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Min
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max@2
	npad	7
$LL2@Max@2:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Max
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR [ecx+8]

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@2:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@2
$LN1@Erase@2:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min@3
$LL2@Min@3:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min@3
$LN1@Min@3:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Min
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max@3
	npad	7
$LL2@Max@3:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max@3
$LN1@Max@3:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Max
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR [ecx+8]

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Lrotate@3:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@3:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN2@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@3:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@3
$LL3@Erase@3:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@3
$LN1@Erase@3:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root, COMDAT
; _this$ = eax

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [eax+24]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min@4
$LL2@Min@4:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min@4
$LN1@Min@4:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max@4
	npad	7
$LL2@Max@4:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max@4
$LN1@Max@4:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR [ecx+8]

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Lrotate@4

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Lrotate@4:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Lrotate@4

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@4:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN2@Lrotate@4

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@4:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@4
$LL3@Erase@4:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@4
$LN1@Erase@4:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@3
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@3
$LN4@operator@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@3:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	0
??8const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 451  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@iterator
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@iterator:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 452  : 			}

	mov	eax, esi
	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@4
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@4
$LN4@operator@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@4:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	0
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::iterator::iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 451  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@iterator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@iterator@2:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 452  : 			}

	mov	eax, esi
	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@5
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@5
$LN4@operator@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@5:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	0
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::iterator::iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 451  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@iterator@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@iterator@3:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 452  : 			}

	mov	eax, esi
	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@6
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@6
$LN4@operator@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@6:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	0
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 451  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@iterator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@iterator@4:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 452  : 			}

	mov	eax, esi
	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+24]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::clear, COMDAT
; _this$ = eax

; 965  : 		{	// erase all

	push	esi
	mov	esi, eax

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 575  : 		{	// make iterator from const_iterator

	push	ebx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	ebx, DWORD PTR __Where$[esp+4]
	test	edi, edi
	jne	SHORT $LN7@Make_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Make_iter:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi

; 577  : 		}

	pop	ebx
	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+24]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::clear, COMDAT
; _this$ = eax

; 965  : 		{	// erase all

	push	esi
	mov	esi, eax

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 575  : 		{	// make iterator from const_iterator

	push	ebx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	ebx, DWORD PTR __Where$[esp+4]
	test	edi, edi
	jne	SHORT $LN7@Make_iter@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Make_iter@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi

; 577  : 		}

	pop	ebx
	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+24]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::clear, COMDAT
; _this$ = eax

; 965  : 		{	// erase all

	push	esi
	mov	esi, eax

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 575  : 		{	// make iterator from const_iterator

	push	ebx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	ebx, DWORD PTR __Where$[esp+4]
	test	edi, edi
	jne	SHORT $LN7@Make_iter@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Make_iter@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi

; 577  : 		}

	pop	ebx
	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+24]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear, COMDAT
; _this$ = eax

; 965  : 		{	// erase all

	push	esi
	mov	esi, eax

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 575  : 		{	// make iterator from const_iterator

	push	ebx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	ebx, DWORD PTR __Where$[esp+4]
	test	edi, edi
	jne	SHORT $LN7@Make_iter@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Make_iter@4:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi

; 577  : 		}

	pop	ebx
	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,HandlerInfo> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::~_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>::~_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>::~_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\lightweightstack.h
_TEXT	ENDS
;	COMDAT ??0?$LightweightStack@UStackEntry@@@@QAE@XZ
_TEXT	SEGMENT
??0?$LightweightStack@UStackEntry@@@@QAE@XZ PROC	; LightweightStack<StackEntry>::LightweightStack<StackEntry>, COMDAT
; _this$ = eax

; 47   : 	LightweightStack() {

	push	ebx

; 48   : 		array = (T *)stackAllocator.malloc(64 * sizeof(T));

	mov	ecx, 1536				; 00000600H
	mov	edx, OFFSET ?stackAllocator@@3UfastAllocator@@A+4
	lock	 xadd	 DWORD PTR [edx], ecx
	mov	edx, DWORD PTR ?stackAllocator@@3UfastAllocator@@A+8
	sub	edx, ecx
	xor	ebx, ebx
	cmp	edx, 1536				; 00000600H
	setle	bl
	dec	ebx
	and	ecx, ebx

; 49   : 		arrayEnd = array + 64;

	lea	edx, DWORD PTR [ecx+1536]
	mov	DWORD PTR [eax], ecx

; 50   : 		topPointer = array - 1;

	add	ecx, -24				; ffffffe8H
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 51   : 	}

	ret	0
??0?$LightweightStack@UStackEntry@@@@QAE@XZ ENDP	; LightweightStack<StackEntry>::LightweightStack<StackEntry>
_TEXT	ENDS
PUBLIC	_ActivateProfiler@0
; Function compile flags: /Ogtpy
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\main.cpp
;	COMDAT _ActivateProfiler@0
_TEXT	SEGMENT
_ActivateProfiler@0 PROC				; COMDAT

; 83   : 		profiler.Activate();

	mov	eax, DWORD PTR ?tls_index@@3KA		; tls_index
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4
	mov	BYTE PTR [eax+8], 1

; 84   : 	}

	ret	0
_ActivateProfiler@0 ENDP
_TEXT	ENDS
PUBLIC	_DeactivateProfiler@0
; Function compile flags: /Ogtpy
;	COMDAT _DeactivateProfiler@0
_TEXT	SEGMENT
_DeactivateProfiler@0 PROC				; COMDAT

; 78   : 		profiler.Deactivate();

	mov	eax, DWORD PTR ?tls_index@@3KA		; tls_index
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4
	mov	BYTE PTR [eax+8], 0

; 79   : 	}

	ret	0
_DeactivateProfiler@0 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Message$ = 12						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	ecx, esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 130  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
tv324 = -40						; size = 4
$T140802 = -36						; size = 4
__Val$ = -32						; size = 4
__Pad$ = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 655  : 	{	// insert NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi
	mov	eax, OFFSET ??_C@_02JMMFPCED@?$CC?$CC?$AA@

; 656  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Val$[ebp], eax
	mov	DWORD PTR __State$[ebp], edi

; 657  : 	streamsize _Count = (streamsize)::strlen(_Val);	// may overflow

	lea	edx, DWORD PTR [eax+1]
$LL82@operator@29:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL82@operator@29
	sub	eax, edx
	mov	ebx, eax

; 658  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 659  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	cmp	eax, edi
	jle	SHORT $LN20@operator@29
	cmp	eax, ebx
	jle	SHORT $LN20@operator@29
	sub	eax, ebx
	mov	edi, eax
$LN20@operator@29:

; 660  : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	lea	edx, DWORD PTR __Ok$[ebp]
	push	edx
	mov	DWORD PTR __Pad$[ebp], edi
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 661  : 
; 662  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN17@operator@29

; 663  : 		_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4

; 664  : 	else

	jmp	$LN27@operator@29
$LN17@operator@29:

; 665  : 		{	// state okay, insert characters
; 666  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 667  : 		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T140802[ebp]
	push	eax
	add	ecx, esi
	call	DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	lea	ecx, DWORD PTR $T140802[ebp]
	mov	DWORD PTR tv324[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	DWORD PTR __imp_??1locale@std@@QAE@XZ

; 668  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LL80@operator@29
	npad	4
$LL13@operator@29:

; 669  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jle	SHORT $LL80@operator@29

; 670  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 671  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	movzx	edx, WORD PTR [eax+48]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN12@operator@29

; 672  : 					{	// insertion failed, quit
; 673  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
	npad	3
$LL80@operator@29:

; 674  : 					break;
; 675  : 					}
; 676  : 
; 677  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@29
	test	ebx, ebx
	jle	SHORT $LL81@operator@29

; 678  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 679  : 				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR tv324[ebp]
	mov	edi, DWORD PTR [eax+esi+40]
	push	edx
	call	DWORD PTR __imp_?widen@?$ctype@_W@std@@QBE_WD@Z
	movzx	eax, ax
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN8@operator@29

; 680  : 					_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN8@operator@29:

; 674  : 					break;
; 675  : 					}
; 676  : 
; 677  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

	mov	edi, DWORD PTR __Pad$[ebp]
	dec	ebx
	inc	DWORD PTR __Val$[ebp]
	jmp	SHORT $LL80@operator@29
$LN12@operator@29:

; 669  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	edi
	mov	DWORD PTR __Pad$[ebp], edi
	jmp	$LL13@operator@29
$LL81@operator@29:

; 681  : 
; 682  : 		if (_State == ios_base::goodbit)
; 683  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jle	SHORT $LN2@operator@29

; 684  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 685  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN3@operator@29

; 686  : 					{	// insertion failed, quit
; 687  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN2@operator@29:

; 688  : 					break;
; 689  : 					}
; 690  : 		_Ostr.width(0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	jmp	SHORT $LN27@operator@29
$LN3@operator@29:

; 681  : 
; 682  : 		if (_State == ios_base::goodbit)
; 683  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	edi
	jmp	SHORT $LL81@operator@29
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0:

; 691  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN88@operator@29
	ret	0
$LN88@operator@29:
	mov	esi, DWORD PTR __Ostr$[ebp]
$LN27@operator@29:

; 692  : 		}
; 693  : 
; 694  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	push	edx
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 695  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN62@operator@29
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN62@operator@29:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax+40]
	test	ecx, ecx
	je	SHORT $LN85@operator@29
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN85@operator@29:

; 696  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR $T140802[ebp]
	jmp	DWORD PTR __imp_??1locale@std@@QAE@XZ
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = esi

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN9@Inc
	call	edi
$LN9@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	edi
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+29], 0
	jne	SHORT $LN40@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN23@Inc
	npad	4
$LL24@Inc:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL24@Inc
$LN23@Inc:
	mov	DWORD PTR [esi+4], ecx
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN40@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [esi+4], eax
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = esi

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN9@Inc@2
	call	edi
$LN9@Inc@2:

; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN6@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	edi
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN6@Inc@2:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN40@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN23@Inc@2
	npad	4
$LL24@Inc@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL24@Inc@2
$LN23@Inc@2:
	mov	DWORD PTR [esi+4], ecx
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN40@Inc@2:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@2
$LL2@Inc@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [esi+4], eax
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = esi

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN9@Inc@3
	call	edi
$LN9@Inc@3:

; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN6@Inc@3

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	edi
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN6@Inc@3:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN40@Inc@3

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN23@Inc@3
	npad	4
$LL24@Inc@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL24@Inc@3
$LN23@Inc@3:
	mov	DWORD PTR [esi+4], ecx
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN40@Inc@3:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@3
$LL2@Inc@3:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@3

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@3
$LN1@Inc@3:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [esi+4], eax
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = esi

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN9@Inc@4
	call	edi
$LN9@Inc@4:

; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN6@Inc@4

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	edi
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN6@Inc@4:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN40@Inc@4

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN23@Inc@4
	npad	4
$LL24@Inc@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL24@Inc@4
$LN23@Inc@4:
	mov	DWORD PTR [esi+4], ecx
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
$LN40@Inc@4:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@4
$LL2@Inc@4:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@4

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@4
$LN1@Inc@4:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [esi+4], eax
	pop	edi

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 273  : 			{	// preincrement

	push	esi
	mov	esi, eax

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 273  : 			{	// preincrement

	push	esi
	mov	esi, eax

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 273  : 			{	// preincrement

	push	esi
	mov	esi, eax

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 273  : 			{	// preincrement

	push	esi
	mov	esi, eax

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR [ecx]

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+29], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR [ecx]

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@2:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR [ecx]

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Rrotate@3:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@3:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jne	SHORT $LN2@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@3:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR [ecx]

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN5@Rrotate@4

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$LN5@Rrotate@4:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN4@Rrotate@4

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@4:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jne	SHORT $LN2@Rrotate@4

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@4:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@30
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@30
$LN6@operator@30:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@30:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	0
??9const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 279  : 			{	// postincrement

	push	esi
	mov	esi, eax

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, edi
	pop	esi

; 283  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@31
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@31
$LN6@operator@31:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@31:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	0
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 279  : 			{	// postincrement

	push	esi
	mov	esi, eax

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, edi
	pop	esi

; 283  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@32
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@32
$LN6@operator@32:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@32:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	0
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 279  : 			{	// postincrement

	push	esi
	mov	esi, eax

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, edi
	pop	esi

; 283  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@33
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@33
$LN6@operator@33:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@33:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	0
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 279  : 			{	// postincrement

	push	esi
	mov	esi, eax

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, edi
	pop	esi

; 283  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
$T141550 = -80						; size = 28
$T141549 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Erasednode$ = 8					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase, COMDAT

; 764  : 		{	// erase element at _Where

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+12]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+29], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+88]
	push	esi
	push	edi
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T141550[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T141550[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T141549[esp+104]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T141549[esp+104]
	push	edx
	call	__CxxThrowException@8
$LN310@erase:
$LN40@erase:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	esi, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+96], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN305@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN305@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+100]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN305@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+29], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+24]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	edx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+29], 0
	je	SHORT $LN43@erase
	mov	ecx, esi
	jmp	SHORT $LN98@erase
$LN43@erase:
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+29], 0
	mov	ecx, edi
	jne	SHORT $LN98@erase
$LL99@erase:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL99@erase
$LN98@erase:
	mov	DWORD PTR [edx], ecx
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN176@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+29], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Max
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+29], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+28]
	add	eax, 28					; 0000001cH
	cmp	eax, ecx
	je	SHORT $LN176@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN176@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+96]
	mov	bl, 1
	cmp	BYTE PTR [edx+28], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	3
$LL18@erase:
	cmp	BYTE PTR [edi+28], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+28], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+28], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+28], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN308@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN11@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+28], bl
	je	SHORT $LN309@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+28], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+28], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+28]
	mov	BYTE PTR [ecx+28], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+28], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+28], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+28], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+28], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+28], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+29], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN308@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN4@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+28], bl
	jne	SHORT $LN4@erase
$LN309@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [ecx+28], 0
$LN308@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR [ebp+24]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+28], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+28], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+28], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+28]
	mov	BYTE PTR [ecx+28], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+28], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+28], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+28], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+28]
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+28], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	eax, DWORD PTR __Where$[esp+100]

; 931  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR [edx+4], eax
	pop	ebp
	mov	eax, edx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN307@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T141550[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
$T142031 = -80						; size = 28
$T142030 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Erasednode$ = 8					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase, COMDAT

; 764  : 		{	// erase element at _Where

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+12]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+88]
	push	esi
	push	edi
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T142031[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T142031[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T142030[esp+104]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T142030[esp+104]
	push	edx
	call	__CxxThrowException@8
$LN310@erase@2:
$LN40@erase@2:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	esi, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+96], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN305@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN305@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+100]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@2
$LN305@erase@2:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+24]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	edx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase@2
	mov	ecx, esi
	jmp	SHORT $LN98@erase@2
$LN43@erase@2:
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+21], 0
	mov	ecx, edi
	jne	SHORT $LN98@erase@2
$LL99@erase@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL99@erase@2
$LN98@erase@2:
	mov	DWORD PTR [edx], ecx
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN176@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase@2
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@2
$LN45@erase@2:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Max
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN176@erase@2
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN176@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+96]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@2
	npad	3
$LL18@erase@2:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN308@erase@2

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN11@erase@2
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+20], bl
	je	SHORT $LN309@erase@2
$LN11@erase@2:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN15@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN308@erase@2

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase@2
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+20], bl
	jne	SHORT $LN4@erase@2
$LN309@erase@2:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [ecx+20], 0
$LN308@erase@2:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR [ebp+24]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+4]
	jne	$LL18@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@2
$LN4@erase@2:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Rrotate
$LN16@erase@2:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+28]
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+28], eax
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	eax, DWORD PTR __Where$[esp+100]

; 931  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR [edx+4], eax
	pop	ebp
	mov	eax, edx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN307@erase@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T142031[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
$T142512 = -80						; size = 28
$T142511 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Erasednode$ = 8					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase, COMDAT

; 764  : 		{	// erase element at _Where

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+12]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+88]
	push	esi
	push	edi
	je	SHORT $LN40@erase@3

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T142512[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T142512[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T142511[esp+104]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T142511[esp+104]
	push	edx
	call	__CxxThrowException@8
$LN310@erase@3:
$LN40@erase@3:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	esi, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+96], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase@3

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN305@erase@3
$LN39@erase@3:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN37@erase@3

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN305@erase@3
$LN37@erase@3:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+100]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@3
$LN305@erase@3:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@3

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@3:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+24]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@3

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@3
$LN33@erase@3:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@3

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@3
$LN31@erase@3:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@3:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	edx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN29@erase@3

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase@3
	mov	ecx, esi
	jmp	SHORT $LN98@erase@3
$LN43@erase@3:
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+21], 0
	mov	ecx, edi
	jne	SHORT $LN98@erase@3
$LL99@erase@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL99@erase@3
$LN98@erase@3:
	mov	DWORD PTR [edx], ecx
$LN29@erase@3:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN176@erase@3

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase@3
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@3
$LN45@erase@3:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Max
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@3
$LN35@erase@3:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@3

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@3
$LN26@erase@3:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@3

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@3:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@3:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@3

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@3
$LN23@erase@3:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@3

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@3
$LN21@erase@3:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@3:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN176@erase@3
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN176@erase@3:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+96]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@3
	npad	3
$LL18@erase@3:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase@3

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN15@erase@3

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN14@erase@3

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN14@erase@3:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN308@erase@3

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN11@erase@3
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+20], bl
	je	SHORT $LN309@erase@3
$LN11@erase@3:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN9@erase@3

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN9@erase@3:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@3
$LN15@erase@3:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN7@erase@3

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN7@erase@3:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN308@erase@3

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase@3
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+20], bl
	jne	SHORT $LN4@erase@3
$LN309@erase@3:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [ecx+20], 0
$LN308@erase@3:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR [ebp+24]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+4]
	jne	$LL18@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@3
$LN4@erase@3:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN2@erase@3

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN2@erase@3:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Rrotate
$LN16@erase@3:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase@3:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+28]
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN1@erase@3

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+28], eax
$LN1@erase@3:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	eax, DWORD PTR __Where$[esp+100]

; 931  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR [edx+4], eax
	pop	ebp
	mov	eax, edx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN307@erase@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T142512[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
$T142993 = -80						; size = 28
$T142992 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Erasednode$ = 8					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT

; 764  : 		{	// erase element at _Where

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+12]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+88]
	push	esi
	push	edi
	je	SHORT $LN40@erase@4

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T142993[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T142993[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T142992[esp+104]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T142992[esp+104]
	push	edx
	call	__CxxThrowException@8
$LN310@erase@4:
$LN40@erase@4:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	esi, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+96], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase@4

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN305@erase@4
$LN39@erase@4:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN37@erase@4

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN305@erase@4
$LN37@erase@4:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+100]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase@4
$LN305@erase@4:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase@4

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@4:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+24]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase@4

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@4
$LN33@erase@4:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase@4

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@4
$LN31@erase@4:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@4:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	edx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [edx], ebx
	jne	SHORT $LN29@erase@4

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase@4
	mov	ecx, esi
	jmp	SHORT $LN98@erase@4
$LN43@erase@4:
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+21], 0
	mov	ecx, edi
	jne	SHORT $LN98@erase@4
$LL99@erase@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL99@erase@4
$LN98@erase@4:
	mov	DWORD PTR [edx], ecx
$LN29@erase@4:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN176@erase@4

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase@4
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@4
$LN45@erase@4:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN176@erase@4
$LN35@erase@4:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase@4

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@4
$LN26@erase@4:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@4

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@4:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@4:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+24]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase@4

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@4
$LN23@erase@4:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase@4

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@4
$LN21@erase@4:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@4:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN176@erase@4
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN176@erase@4:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+96]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase@4

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase@4
	npad	3
$LL18@erase@4:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase@4

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN15@erase@4

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN14@erase@4

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN14@erase@4:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN308@erase@4

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN11@erase@4
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+20], bl
	je	SHORT $LN309@erase@4
$LN11@erase@4:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN9@erase@4

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN9@erase@4:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@4
$LN15@erase@4:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [ecx+20], 0
	jne	SHORT $LN7@erase@4

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN7@erase@4:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN308@erase@4

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase@4
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+20], bl
	jne	SHORT $LN4@erase@4
$LN309@erase@4:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [ecx+20], 0
$LN308@erase@4:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR [ebp+24]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+4]
	jne	$LL18@erase@4

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@4
$LN4@erase@4:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN2@erase@4

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	ebp
	mov	BYTE PTR [ecx+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN2@erase@4:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+20], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	ebp
	mov	ecx, esi
	mov	BYTE PTR [eax+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
$LN16@erase@4:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase@4:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[esp+96]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+28]
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN1@erase@4

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+28], eax
$LN1@erase@4:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	eax, DWORD PTR __Where$[esp+100]

; 931  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR [edx+4], eax
	pop	ebp
	mov	eax, edx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN307@erase@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T142993[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T143476 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase, COMDAT
; _this$ = eax

; 934  : 		{	// erase [_First, _Last)

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, eax

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR __First$[esp+20]
	test	eax, eax
	je	SHORT $LN32@erase@5
	cmp	eax, ecx
	je	SHORT $LN31@erase@5
$LN32@erase@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+20]
$LN31@erase@5:
	mov	ecx, DWORD PTR __First$[esp+24]
	cmp	ecx, edi
	jne	SHORT $LL2@erase@5
	cmp	DWORD PTR __Last$[esp+20], 0
	mov	edi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi]
	je	SHORT $LN61@erase@5
	cmp	DWORD PTR __Last$[esp+20], edx
	je	SHORT $LN60@erase@5
$LN61@erase@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN60@erase@5:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebp], edx

; 944  : 			return (_Make_iter(_First));

	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx

; 945  : 			}
; 946  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@5:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	test	eax, eax
	je	SHORT $LN114@erase@5
	cmp	eax, DWORD PTR __Last$[esp+20]
	je	SHORT $LN113@erase@5
$LN114@erase@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN113@erase@5:
	cmp	ecx, DWORD PTR __Last$[esp+24]
	je	SHORT $LN1@erase@5

; 943  : 				erase(_First++);

	mov	edi, eax
	mov	ebx, ecx
	test	eax, eax
	jne	SHORT $LN134@erase@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
$LN134@erase@5:
	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LN131@erase@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	SHORT $LN128@erase@5
$LN131@erase@5:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN184@erase@5
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN148@erase@5
$LL149@erase@5:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL149@erase@5
$LN148@erase@5:
	mov	DWORD PTR __First$[esp+24], ecx
	jmp	SHORT $LN128@erase@5
$LN184@erase@5:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN126@erase@5
$LL127@erase@5:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN126@erase@5
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+24], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+29], 0
	je	SHORT $LL127@erase@5
$LN126@erase@5:
	mov	DWORD PTR __First$[esp+24], eax
$LN128@erase@5:
	push	ebx
	push	edi
	lea	eax, DWORD PTR $T143476[esp+32]
	push	eax
	push	esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
	jmp	$LL2@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	esi, DWORD PTR [esi]

; 945  : 			}
; 946  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T144099 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase, COMDAT
; _this$ = eax

; 934  : 		{	// erase [_First, _Last)

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, eax

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR __First$[esp+20]
	test	eax, eax
	je	SHORT $LN32@erase@6
	cmp	eax, ecx
	je	SHORT $LN31@erase@6
$LN32@erase@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+20]
$LN31@erase@6:
	mov	ecx, DWORD PTR __First$[esp+24]
	cmp	ecx, edi
	jne	SHORT $LL2@erase@6
	cmp	DWORD PTR __Last$[esp+20], 0
	mov	edi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi]
	je	SHORT $LN61@erase@6
	cmp	DWORD PTR __Last$[esp+20], edx
	je	SHORT $LN60@erase@6
$LN61@erase@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN60@erase@6:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@6

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebp], edx

; 944  : 			return (_Make_iter(_First));

	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx

; 945  : 			}
; 946  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@6:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	test	eax, eax
	je	SHORT $LN114@erase@6
	cmp	eax, DWORD PTR __Last$[esp+20]
	je	SHORT $LN113@erase@6
$LN114@erase@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN113@erase@6:
	cmp	ecx, DWORD PTR __Last$[esp+24]
	je	SHORT $LN1@erase@6

; 943  : 				erase(_First++);

	mov	edi, eax
	mov	ebx, ecx
	test	eax, eax
	jne	SHORT $LN134@erase@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
$LN134@erase@6:
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN131@erase@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	SHORT $LN128@erase@6
$LN131@erase@6:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN184@erase@6
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN148@erase@6
$LL149@erase@6:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL149@erase@6
$LN148@erase@6:
	mov	DWORD PTR __First$[esp+24], ecx
	jmp	SHORT $LN128@erase@6
$LN184@erase@6:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN126@erase@6
$LL127@erase@6:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN126@erase@6
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+24], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL127@erase@6
$LN126@erase@6:
	mov	DWORD PTR __First$[esp+24], eax
$LN128@erase@6:
	push	ebx
	push	edi
	lea	eax, DWORD PTR $T144099[esp+32]
	push	eax
	push	esi
	call	?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
	jmp	$LL2@erase@6
$LN1@erase@6:

; 944  : 			return (_Make_iter(_First));

	mov	esi, DWORD PTR [esi]

; 945  : 			}
; 946  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T144722 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase, COMDAT
; _this$ = eax

; 934  : 		{	// erase [_First, _Last)

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, eax

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR __First$[esp+20]
	test	eax, eax
	je	SHORT $LN32@erase@7
	cmp	eax, ecx
	je	SHORT $LN31@erase@7
$LN32@erase@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+20]
$LN31@erase@7:
	mov	ecx, DWORD PTR __First$[esp+24]
	cmp	ecx, edi
	jne	SHORT $LL2@erase@7
	cmp	DWORD PTR __Last$[esp+20], 0
	mov	edi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi]
	je	SHORT $LN61@erase@7
	cmp	DWORD PTR __Last$[esp+20], edx
	je	SHORT $LN60@erase@7
$LN61@erase@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN60@erase@7:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@7

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebp], edx

; 944  : 			return (_Make_iter(_First));

	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx

; 945  : 			}
; 946  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@7:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	test	eax, eax
	je	SHORT $LN114@erase@7
	cmp	eax, DWORD PTR __Last$[esp+20]
	je	SHORT $LN113@erase@7
$LN114@erase@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN113@erase@7:
	cmp	ecx, DWORD PTR __Last$[esp+24]
	je	SHORT $LN1@erase@7

; 943  : 				erase(_First++);

	mov	edi, eax
	mov	ebx, ecx
	test	eax, eax
	jne	SHORT $LN134@erase@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
$LN134@erase@7:
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN131@erase@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	SHORT $LN128@erase@7
$LN131@erase@7:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN184@erase@7
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN148@erase@7
$LL149@erase@7:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL149@erase@7
$LN148@erase@7:
	mov	DWORD PTR __First$[esp+24], ecx
	jmp	SHORT $LN128@erase@7
$LN184@erase@7:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN126@erase@7
$LL127@erase@7:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN126@erase@7
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+24], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL127@erase@7
$LN126@erase@7:
	mov	DWORD PTR __First$[esp+24], eax
$LN128@erase@7:
	push	ebx
	push	edi
	lea	eax, DWORD PTR $T144722[esp+32]
	push	eax
	push	esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
	jmp	$LL2@erase@7
$LN1@erase@7:

; 944  : 			return (_Make_iter(_First));

	mov	esi, DWORD PTR [esi]

; 945  : 			}
; 946  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T145345 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = eax

; 934  : 		{	// erase [_First, _Last)

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, eax

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR __First$[esp+20]
	test	eax, eax
	je	SHORT $LN32@erase@8
	cmp	eax, ecx
	je	SHORT $LN31@erase@8
$LN32@erase@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+20]
$LN31@erase@8:
	mov	ecx, DWORD PTR __First$[esp+24]
	cmp	ecx, edi
	jne	SHORT $LL2@erase@8
	cmp	DWORD PTR __Last$[esp+20], 0
	mov	edi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi]
	je	SHORT $LN61@erase@8
	cmp	DWORD PTR __Last$[esp+20], edx
	je	SHORT $LN60@erase@8
$LN61@erase@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN60@erase@8:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@8

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebp], edx

; 944  : 			return (_Make_iter(_First));

	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx

; 945  : 			}
; 946  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@8:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	test	eax, eax
	je	SHORT $LN114@erase@8
	cmp	eax, DWORD PTR __Last$[esp+20]
	je	SHORT $LN113@erase@8
$LN114@erase@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
$LN113@erase@8:
	cmp	ecx, DWORD PTR __Last$[esp+24]
	je	SHORT $LN1@erase@8

; 943  : 				erase(_First++);

	mov	edi, eax
	mov	ebx, ecx
	test	eax, eax
	jne	SHORT $LN134@erase@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+24]
$LN134@erase@8:
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN131@erase@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	SHORT $LN128@erase@8
$LN131@erase@8:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN184@erase@8
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN148@erase@8
$LL149@erase@8:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL149@erase@8
$LN148@erase@8:
	mov	DWORD PTR __First$[esp+24], ecx
	jmp	SHORT $LN128@erase@8
$LN184@erase@8:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN126@erase@8
$LL127@erase@8:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN126@erase@8
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+24], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL127@erase@8
$LN126@erase@8:
	mov	DWORD PTR __First$[esp+24], eax
$LN128@erase@8:
	push	ebx
	push	edi
	lea	eax, DWORD PTR $T145345[esp+32]
	push	eax
	push	esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+24]
	mov	eax, DWORD PTR __First$[esp+20]
	jmp	$LL2@erase@8
$LN1@erase@8:

; 944  : 			return (_Make_iter(_First));

	mov	esi, DWORD PTR [esi]

; 945  : 			}
; 946  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T145969 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	sub	esp, 8
	push	eax
	push	ecx
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T145969[esp+24]
	push	eax
	mov	eax, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T146143 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	sub	esp, 8
	push	eax
	push	ecx
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T146143[esp+24]
	push	eax
	mov	eax, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T146317 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	sub	esp, 8
	push	eax
	push	ecx
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T146317[esp+24]
	push	eax
	mov	eax, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T146491 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	sub	esp, 8
	push	eax
	push	ecx
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T146491[esp+24]
	push	eax
	mov	eax, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >, COMDAT

; 539  : 		{	// destroy tree

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 540  : 		_Tidy();

	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy

; 541  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >, COMDAT

; 539  : 		{	// destroy tree

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 540  : 		_Tidy();

	call	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy

; 541  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >, COMDAT

; 539  : 		{	// destroy tree

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 540  : 		_Tidy();

	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy

; 541  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT

; 539  : 		{	// destroy tree

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 540  : 		_Tidy();

	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 541  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z ; EscapeString
;	COMDAT xdata$x
; File e:\program\c#\sharpdevelop5\src\addins\analysis\profiler\hook\main.cpp
xdata$x	SEGMENT
__unwindtable$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1
__ehfuncinfo$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
_TEXT	SEGMENT
$T147645 = -180						; size = 4
$T147641 = -176						; size = 28
_output$ = -148						; size = 128
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z PROC ; EscapeString, COMDAT
; _input$ = ecx

; 60   : {

	push	-1
	push	__ehhandler$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+188]

; 61   : 	std::wostringstream output;

	push	1
	mov	esi, ecx
	push	2
	lea	ecx, DWORD PTR _output$[esp+200]
	mov	DWORD PTR $T147645[esp+200], 0
	call	DWORD PTR __imp_??0?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z

; 62   : 	output.str(L"");

	push	OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
	lea	ecx, DWORD PTR $T147641[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	lea	eax, DWORD PTR $T147641[esp+192]
	push	eax
	lea	ecx, DWORD PTR _output$[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 2
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	lea	ecx, DWORD PTR $T147641[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 63   : 	
; 64   : 	for (const WCHAR *ptr = input; *ptr != 0; ptr++) {

	cmp	WORD PTR [esi], 0
	je	SHORT $LN3@EscapeStri
$LL5@EscapeStri:

; 65   : 		WCHAR c = *ptr;

	movzx	eax, WORD PTR [esi]

; 66   : 		if (c == '"')

	cmp	ax, 34					; 00000022H
	jne	SHORT $LN2@EscapeStri

; 67   : 			output << "\"\"";

	lea	ecx, DWORD PTR _output$[esp+192]
	push	ecx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 4

; 68   : 		else

	jmp	SHORT $LN4@EscapeStri
$LN2@EscapeStri:

; 69   : 			output << c;

	push	eax
	lea	edx, DWORD PTR _output$[esp+196]
	push	edx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN4@EscapeStri:
	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL5@EscapeStri
$LN3@EscapeStri:

; 70   : 	}
; 71   : 	
; 72   : 	return output.str();

	push	edi
	lea	ecx, DWORD PTR _output$[esp+196]
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
	lea	ecx, DWORD PTR _output$[esp+192]
	mov	DWORD PTR $T147645[esp+192], 1
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ

; 73   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+192]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 184				; 000000b8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$0:
	lea	ecx, DWORD PTR _output$[ebp]
	jmp	DWORD PTR __imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$1:
	lea	ecx, DWORD PTR $T147641[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__unwindfunclet$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z$2:
	mov	eax, DWORD PTR $T147645[ebp]
	and	eax, 1
	je	$LN11@EscapeStri
	and	DWORD PTR $T147645[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$LN11@EscapeStri:
	ret	0
__ehhandler$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z:
	mov	eax, OFFSET __ehfuncinfo$?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z ENDP ; EscapeString
PUBLIC	??0ThreadLocalData@@QAE@XZ			; ThreadLocalData::ThreadLocalData
; Function compile flags: /Ogtpy
;	COMDAT ??0ThreadLocalData@@QAE@XZ
_TEXT	SEGMENT
??0ThreadLocalData@@QAE@XZ PROC				; ThreadLocalData::ThreadLocalData, COMDAT
; _this$ = esi

; 49   : {

	mov	eax, 1536				; 00000600H
	mov	ecx, OFFSET ?stackAllocator@@3UfastAllocator@@A+4
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ?stackAllocator@@3UfastAllocator@@A+8
	sub	edx, eax
	xor	ecx, ecx
	cmp	edx, 1536				; 00000600H
	setle	cl
	dec	ecx
	and	eax, ecx
	lea	edx, DWORD PTR [eax+1536]
	mov	DWORD PTR [esi+20], eax
	add	eax, -24				; ffffffe8H
	mov	DWORD PTR [esi+28], edx
	mov	DWORD PTR [esi+24], eax

; 50   : 	this->threadID = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR [esi], eax

; 51   : }

	mov	eax, esi
	ret	0
??0ThreadLocalData@@QAE@XZ ENDP				; ThreadLocalData::ThreadLocalData
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >::~map<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >::~map<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >::~map<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CProfiler@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$10
	DD	06H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$12
	DD	05H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$14
	DD	04H
	DD	FLAT:__unwindfunclet$??1CProfiler@@QAE@XZ$16
__ehfuncinfo$??1CProfiler@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1CProfiler@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CProfiler@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T149833 = -16						; size = 4
$T149559 = -16						; size = 4
$T149285 = -16						; size = 4
$T149011 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CProfiler@@QAE@XZ PROC				; CProfiler::~CProfiler, COMDAT
	push	-1
	push	__ehhandler$??1CProfiler@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[esp+24], OFFSET ?profiler@@3VCProfiler@@A ; profiler
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	esi, OFFSET ?profiler@@3VCProfiler@@A+244
	mov	DWORD PTR $T149011[esp+24], esi
	mov	BYTE PTR __$EHRec$[esp+32], 8
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,HandlerInfo,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,HandlerInfo> >,0> >::_Tidy
	mov	eax, DWORD PTR ?profiler@@3VCProfiler@@A+244
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	esi, OFFSET ?profiler@@3VCProfiler@@A+212
	add	esp, 4
	mov	DWORD PTR $T149285[esp+24], esi
	mov	BYTE PTR __$EHRec$[esp+32], 9
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,ThreadInfo *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,ThreadInfo *> >,0> >::_Tidy
	mov	ecx, DWORD PTR ?profiler@@3VCProfiler@@A+212
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	esi, OFFSET ?profiler@@3VCProfiler@@A+180
	add	esp, 4
	mov	DWORD PTR $T149559[esp+24], esi
	mov	BYTE PTR __$EHRec$[esp+32], 10		; 0000000aH
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,ThreadInfo *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,ThreadInfo *> >,0> >::_Tidy
	mov	edx, DWORD PTR ?profiler@@3VCProfiler@@A+180
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	mov	esi, OFFSET ?profiler@@3VCProfiler@@A+148
	add	esp, 4
	mov	DWORD PTR $T149833[esp+24], esi
	mov	BYTE PTR __$EHRec$[esp+32], 11		; 0000000bH
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
	mov	eax, DWORD PTR ?profiler@@3VCProfiler@@A+148
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	esi, DWORD PTR __imp__DeleteCriticalSection@4
	add	esp, 4
	push	OFFSET ?profiler@@3VCProfiler@@A+116
	call	esi
	push	OFFSET ?profiler@@3VCProfiler@@A+92
	call	esi
	push	OFFSET ?profiler@@3VCProfiler@@A+68
	call	esi
	push	OFFSET ?profiler@@3VCProfiler@@A+44
	call	esi
	push	OFFSET ?profiler@@3VCProfiler@@A+20
	call	esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CProfiler@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	jmp	??1CriticalSection@@QAE@XZ		; CriticalSection::~CriticalSection
__unwindfunclet$??1CProfiler@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	jmp	??1CriticalSection@@QAE@XZ		; CriticalSection::~CriticalSection
__unwindfunclet$??1CProfiler@@QAE@XZ$2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	jmp	??1CriticalSection@@QAE@XZ		; CriticalSection::~CriticalSection
__unwindfunclet$??1CProfiler@@QAE@XZ$3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	jmp	??1CriticalSection@@QAE@XZ		; CriticalSection::~CriticalSection
__unwindfunclet$??1CProfiler@@QAE@XZ$4:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	jmp	??1CriticalSection@@QAE@XZ		; CriticalSection::~CriticalSection
__unwindfunclet$??1CProfiler@@QAE@XZ$5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	call	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$??1CProfiler@@QAE@XZ$6:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H
	push	eax
	call	??1?$map@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	ret	0
__unwindfunclet$??1CProfiler@@QAE@XZ$7:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	call	??1?$map@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@@std@@QAE@XZ
	ret	0
__unwindfunclet$??1CProfiler@@QAE@XZ$10:
	mov	eax, DWORD PTR $T149011[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IVHandlerInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIVHandlerInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??1CProfiler@@QAE@XZ$12:
	mov	eax, DWORD PTR $T149285[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@KPAVThreadInfo@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??1CProfiler@@QAE@XZ$14:
	mov	eax, DWORD PTR $T149559[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVThreadInfo@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVThreadInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??1CProfiler@@QAE@XZ$16:
	mov	eax, DWORD PTR $T149833[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1CProfiler@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CProfiler@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CProfiler@@QAE@XZ ENDP				; CProfiler::~CProfiler
; Function compile flags: /Ogtpy
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
PUBLIC	_LogEvent@16
; Function compile flags: /Ogtpy
;	COMDAT _LogEvent@16
_TEXT	SEGMENT
$T159160 = -56						; size = 28
$T159159 = -28						; size = 28
_type$ = 8						; size = 4
_id$ = 12						; size = 4
_controlName$ = 16					; size = 4
_controlText$ = 20					; size = 4
_LogEvent@16 PROC					; COMDAT

; 87   : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 56					; 00000038H
	push	esi
	push	edi

; 88   : 		if (controlName == nullptr)

	mov	edi, DWORD PTR _controlName$[ebp]
	test	edi, edi
	jne	SHORT $LN2@LogEvent

; 89   : 			controlName = L"";

	mov	edi, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
$LN2@LogEvent:

; 90   : 		if (controlText == nullptr)

	mov	ecx, DWORD PTR _controlText$[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@LogEvent

; 91   : 			controlText = L"";

	mov	ecx, OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
$LN1@LogEvent:

; 92   : 	
; 93   : 		profiler.LogString(L"event %d %d \"%s:%s\"", type, id, EscapeString(controlName).c_str(), EscapeString(controlText).c_str());

	lea	eax, DWORD PTR $T159159[esp+64]
	push	eax
	call	?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z ; EscapeString
	add	esp, 4
	cmp	DWORD PTR [eax+24], 8
	jb	SHORT $LN9@LogEvent
	mov	esi, DWORD PTR [eax+4]
	jmp	SHORT $LN10@LogEvent
$LN9@LogEvent:
	lea	esi, DWORD PTR [eax+4]
$LN10@LogEvent:
	lea	ecx, DWORD PTR $T159160[esp+64]
	push	ecx
	mov	ecx, edi
	call	?EscapeString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_W@Z ; EscapeString
	add	esp, 4
	cmp	DWORD PTR [eax+24], 8
	jb	SHORT $LN15@LogEvent
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN16@LogEvent
$LN15@LogEvent:
	add	eax, 4
$LN16@LogEvent:
	mov	edx, DWORD PTR _id$[ebp]
	push	esi
	push	eax
	mov	eax, DWORD PTR _type$[ebp]
	push	edx
	push	eax
	push	OFFSET ??_C@_1CI@DFGEPGFH@?$AAe?$AAv?$AAe?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CF?$AAd?$AA?5?$AA?$CC?$AA?$CF?$AAs?$AA?3?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@
	mov	edi, OFFSET ?profiler@@3VCProfiler@@A	; profiler
	call	?LogString@CProfiler@@QAAXPA_WZZ	; CProfiler::LogString
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T159160[esp+64]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T159159[esp+64]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 94   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LogEvent@16 ENDP
; Function compile flags: /Ogtpy
;	COMDAT ??__Emallocator@@YAXXZ
text$yc	SEGMENT
??__Emallocator@@YAXXZ PROC				; `dynamic initializer for 'mallocator'', COMDAT

; 25   : freeListAllocator<FunctionInfoAllocationSize> mallocator;

	jmp	??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QAE@XZ ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>
??__Emallocator@@YAXXZ ENDP				; `dynamic initializer for 'mallocator''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__EstackAllocator@@YAXXZ
text$yc	SEGMENT
??__EstackAllocator@@YAXXZ PROC				; `dynamic initializer for 'stackAllocator'', COMDAT

; 26   : fastAllocator stackAllocator;

	xor	eax, eax
	mov	DWORD PTR ?stackAllocator@@3UfastAllocator@@A+4, eax
	mov	DWORD PTR ?stackAllocator@@3UfastAllocator@@A+8, eax
	ret	0
??__EstackAllocator@@YAXXZ ENDP				; `dynamic initializer for 'stackAllocator''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Eprofiler@@YAXXZ
text$yc	SEGMENT
??__Eprofiler@@YAXXZ PROC				; `dynamic initializer for 'profiler'', COMDAT

; 27   : CProfiler profiler;

	call	??0CProfiler@@QAE@XZ			; CProfiler::CProfiler
	push	OFFSET ??__Fprofiler@@YAXXZ		; `dynamic atexit destructor for 'profiler''
	call	_atexit
	pop	ecx
	ret	0
??__Eprofiler@@YAXXZ ENDP				; `dynamic initializer for 'profiler''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Fprofiler@@YAXXZ
text$yd	SEGMENT
??__Fprofiler@@YAXXZ PROC				; `dynamic atexit destructor for 'profiler'', COMDAT
	jmp	??1CProfiler@@QAE@XZ
??__Fprofiler@@YAXXZ ENDP				; `dynamic atexit destructor for 'profiler''
text$yd	ENDS
PUBLIC	?profiler@@3VCProfiler@@A			; profiler
PUBLIC	?stackAllocator@@3UfastAllocator@@A		; stackAllocator
PUBLIC	?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A ; mallocator
?profiler@@3VCProfiler@@A DB 0114H DUP (?)		; profiler
?stackAllocator@@3UfastAllocator@@A DB 0cH DUP (?)	; stackAllocator
?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A DB 08cH DUP (?) ; mallocator
CRT$XCU	SEGMENT
_mallocator$initializer$ DD FLAT:??__Emallocator@@YAXXZ
_stackAllocator$initializer$ DD FLAT:??__EstackAllocator@@YAXXZ
_profiler$initializer$ DD FLAT:??__Eprofiler@@YAXXZ
CRT$XCU	ENDS
END
